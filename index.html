<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alter</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

    :root {
      /* DEFAULT: Dark Mode */
      --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);

      --glass-panel-bg: rgba(30, 41, 59, 0.6);
      --glass-header-bg: rgba(15, 23, 42, 0.8);
      --glass-sidebar-bg: rgba(15, 23, 42, 0.4);
      --glass-input-bg: rgba(0, 0, 0, 0.2);

      --glass-border: 1px solid rgba(255, 255, 255, 0.1);
      --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);

      --primary-gradient: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);

      --text-main: #f8fafc;
      --text-muted: #94a3b8;
      --text-inverse: #ffffff;

      --border-elegant: 1px solid rgba(255, 255, 255, 0.1);

      --msg-bg-other: rgba(255, 255, 255, 0.08);
      --msg-bg-user: var(--primary-gradient);

      --item-hover-bg: rgba(255, 255, 255, 0.05);

      --radius-md: 16px;
      --radius-lg: 24px;
      --radius-pill: 9999px;
    }

    body.light-mode {
      /* Light Mode Overrides */
      --bg-gradient: linear-gradient(120deg, #f0f4f8 0%, #d9e2ec 100%);

      --glass-panel-bg: rgba(255, 255, 255, 0.75);
      --glass-header-bg: rgba(255, 255, 255, 0.85);
      --glass-sidebar-bg: rgba(255, 255, 255, 0.5);
      --glass-input-bg: rgba(255, 255, 255, 0.8);

      --glass-border: 1px solid rgba(0, 0, 0, 0.05);
      --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.08);

      --text-main: #1e293b;
      --text-muted: #64748b;
      --text-inverse: #ffffff;

      --border-elegant: 1px solid rgba(0, 0, 0, 0.08);

      --msg-bg-other: rgba(255, 255, 255, 0.9);
      --item-hover-bg: rgba(0, 0, 0, 0.05);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }

    body {
      background: var(--bg-gradient);
      color: var(--text-main);
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      transition: background 0.5s ease;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .hidden {
      display: none !important;
    }

    /* Main Container with Glassmorphism */
    .container {
      max-width: 1400px;
      width: 95%;
      height: 92vh;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      border: var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--glass-shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Common Buttons */
    button {
      cursor: pointer;
      border: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: 'Inter', sans-serif;
    }

    button:active {
      transform: scale(0.96);
    }

    .secondary-btn {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
      border: var(--border-elegant);
      padding: 10px 20px;
      /* Ensure good sizing */
      border-radius: var(--radius-pill);
    }

    .secondary-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: var(--text-main);
    }

    /* Inputs */
    input,
    select {
      padding: 14px 20px;
      border: var(--border-elegant);
      background: var(--glass-input-bg);
      border-radius: var(--radius-pill);
      color: var(--text-main);
      transition: all 0.2s ease;
      outline: none;
      font-size: 0.95rem;
    }

    input::placeholder {
      color: var(--text-muted);
      opacity: 0.7;
    }

    input:focus,
    select:focus {
      background: rgba(0, 0, 0, 0.3);
      border-color: #8b5cf6;
      box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
    }

    /* Auth Screens */
    .auth-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
      padding: 2rem;
    }

    .auth-screen h2 {
      margin-bottom: 2rem;
      font-size: 3rem;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 800;
      letter-spacing: -1px;
    }

    .auth-screen h3 {
      color: var(--text-main);
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .auth-screen .auth-form {
      width: 100%;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      background: var(--glass-panel-bg);
      padding: 2rem;
      border-radius: var(--radius-lg);
      border: var(--glass-border);
    }

    .auth-screen input {
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      /* keep simplified for auth, or use var --glass-input-bg */
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .auth-screen button {
      background: var(--primary-gradient);
      color: white;
      padding: 16px;
      border-radius: var(--radius-pill);
      font-weight: 600;
      font-size: 1.1rem;
      box-shadow: 0 10px 20px -5px rgba(99, 102, 241, 0.4);
    }

    .auth-screen button:hover {
      box-shadow: 0 15px 25px -5px rgba(99, 102, 241, 0.5);
      transform: translateY(-2px);
    }

    .auth-screen p {
      margin-top: 1rem;
      color: var(--text-muted);
      text-align: center;
    }

    .auth-screen a {
      color: #a855f7;
      text-decoration: none;
      font-weight: 500;
    }

    /* App Header */
    .app-header {
      background: var(--glass-header-bg);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: var(--border-elegant);
      border-bottom: var(--border-elegant);
      z-index: 20;
    }

    .logo-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-container img {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
    }

    .app-header span {
      font-size: 1.8rem;
      font-weight: 800;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.5px;
    }

    .app-header button {
      margin-left: 10px;
      background: var(--item-hover-bg);
      color: var(--text-main);
      padding: 10px 20px;
      border-radius: var(--radius-pill);
      font-weight: 500;
      font-size: 0.9rem;
      border: var(--border-elegant);
    }

    .app-header button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .app-header button:last-child {
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
      border-color: rgba(239, 68, 68, 0.2);
    }

    .app-header button:last-child:hover {
      background: rgba(239, 68, 68, 0.2);
    }

    /* Layout */
    .layout-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 340px;
      background: var(--glass-sidebar-bg);
      border-right: var(--border-elegant);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar button {
      background: var(--primary-gradient);
      color: white;
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-pill);
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }

    .sidebar h4 {
      padding: 1.5rem 1.5rem 0.5rem;
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

    .chat-list {
      list-style: none;
      padding: 0 1rem 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .chat-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 8px;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .chat-item:hover {
      background: var(--item-hover-bg);
      border: var(--glass-border);
      transform: translateX(4px);
    }

    .chat-item .dp {
      width: 50px;
      height: 50px;
      border-radius: 18px;
      /* Slightly squircle */
      object-fit: cover;
      margin-right: 14px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    .chat-item span {
      font-weight: 600;
      color: var(--text-main);
      font-size: 1rem;
    }

    /* Main Chat Area */
    .main-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: transparent;
      position: relative;
      min-width: 0;
    }

    /* Chat Header */
    .chat-header {
      padding: 0 30px;
      height: 80px;
      border-bottom: var(--border-elegant);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--glass-header-bg);
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 10;
    }

    .chat-header img.dp {
      width: 46px;
      height: 46px;
      border-radius: 16px;
      margin-right: 15px;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .chat-header span {
      color: var(--text-main);
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat-actions button {
      background: var(--item-hover-bg);
      padding: 10px;
      border-radius: 14px;
      width: 44px;
      height: 44px;
      color: var(--text-muted);
      font-size: 1.2rem;
      border: var(--border-elegant);
      margin-left: 8px;
    }

    .chat-actions button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-main);
    }

    /* Messages Area */
    .messages {
      flex: 1;
      padding: 30px;
      overflow-y: auto;
      position: relative;
      z-index: 5;
    }

    #chat-background {
      position: absolute;
      inset: 0;
      z-index: 0;
      overflow: hidden;
      pointer-events: none;
    }

    /* STATIC THEMES */
    /* Theme definitions will apply to #chat-background */

    /* STATIC THEMES - IMAGES */
    /* Theme definitions will apply to #chat-background */

    .theme-default {
      background: transparent;
    }

    .theme-bg1 {
      background-image: url('static/bg1.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg2 {
      background-image: url('static/bg2.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg3 {
      background-image: url('static/bg3.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg4 {
      background-image: url('static/bg4.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg5 {
      background-image: url('static/bg5.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg6 {
      background-image: url('static/bg6.png');
      background-size: cover;
      background-position: center;
    }

    /* Theme Selector UI in Settings */
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }

    .theme-option {
      height: 50px;
      border-radius: 12px;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s, border-color 0.2s;
    }

    .theme-option:hover {
      transform: scale(1.05);
      border-color: white;
    }

    .theme-option.active {
      border-color: #a855f7;
      box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.4);
    }

    .message {
      max-width: 65%;
      padding: 14px 20px;
      margin: 8px 0;
      border-radius: 20px;
      /* More rounded */
      position: relative;
      font-size: 1rem;
      line-height: 1.6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: messagePop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes messagePop {
      0% {
        transform: scale(0.9) translateY(10px);
        opacity: 0;
      }

      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .message.user {
      align-self: flex-end;
      background: var(--msg-bg-user);
      color: white;
      border-bottom-right-radius: 4px;
      /* Distinctive shape */
      box-shadow: 0 8px 20px -5px rgba(124, 58, 237, 0.5);
      /* Glow */
    }

    .message.other {
      align-self: flex-start;
      background: var(--msg-bg-other);
      /* Dark glass message */
      color: var(--text-main);
      border-bottom-left-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      /* keep subtle */
    }

    .message.pending {
      opacity: 0.7;
    }

    .message img {
      max-width: 100%;
      max-height: 250px;
      /* Keep images compact */
      width: auto;
      object-fit: contain;
      border-radius: 12px;
      margin-top: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      /* Indicate clickable */
    }

    .sender-name {
      font-size: 0.8rem;
      font-weight: 700;
      color: #a855f7;
      margin-bottom: 4px;
    }

    /* Reactions updated look */
    .reactions {
      display: flex;
      flex-wrap: wrap;
      margin-top: 6px;
      gap: 6px;
    }

    .reaction {
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-muted);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s;
    }

    .reaction:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.1);
    }

    .message.user .reaction {
      background: rgba(0, 0, 0, 0.2);
      color: rgba(255, 255, 255, 0.9);
      border: none;
    }

    .seen-container {
      display: flex;
      justify-content: flex-end;
      margin-top: 2px;
    }

    .seen-status {
      padding: 2px 6px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: background 0.2s;
    }

    .seen-status:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Input Area */
    .input-area {
      padding: 24px;
      background: var(--glass-header-bg);
      border-top: var(--border-elegant);
      display: flex;
      align-items: center;
      gap: 16px;
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 10;
    }

    .input-area input {
      flex: 1;
      padding: 16px 24px;
      border-radius: var(--radius-pill);
      background: var(--glass-input-bg);
      border: var(--border-elegant);
      font-size: 1rem;
      color: var(--text-main);
    }

    .input-area input::placeholder {
      color: var(--text-muted);
    }

    .input-area button {
      background: var(--primary-gradient);
      color: white;
      width: 54px;
      height: 54px;
      border-radius: 50%;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
    }

    .input-area button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(124, 58, 237, 0.5);
    }

    /* Modals & Popups */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.6);
      /* Darker backdrop */
      backdrop-filter: blur(8px);
    }

    .modal-content {
      /* Content styling */
      background: var(--glass-panel-bg);
      border: var(--glass-border);
      border-radius: 24px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      color: var(--text-main);
      padding: 24px;
      width: 90%;
      max-width: 400px;
    }

    .modal-content h3 {
      color: var(--text-main);
      font-size: 1.8rem;
    }

    #emojiPicker {
      background: rgba(30, 41, 59, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      border-radius: 20px;
      position: fixed;
      /* Changed from default (likely absolute) to fixed */
      z-index: 10000;
      /* High z-index to stay on top */
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      padding: 15px;
      width: 250px;
    }

    .emoji {
      font-size: 1.5rem;
      cursor: pointer;
      text-align: center;
      transition: transform 0.2s;
    }

    .emoji:hover {
      transform: scale(1.2);
    }

    .member-item {
      color: var(--text-main);
      padding: 8px;
      border-radius: 8px;
    }

    .member-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Adjust specific text colors which might be hardcoded in HTML - Handled by class selection */

    /* Mobile Responsiveness */
    #mobileBackBtn {
      display: none;
      margin-right: 10px;
      font-size: 1.2rem;
      background: transparent;
      color: var(--text-main);
      padding: 5px;
      border: none;
    }

    @media (max-width: 768px) {
      .container {
        width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
      }

      .layout-wrapper {
        position: relative;
      }

      /* By default on mobile, show sidebar, hide chat */
      .sidebar {
        width: 100%;
        border-right: none;
        display: flex;
      }

      .main-chat {
        display: none;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: var(--glass-panel-bg);
        /* Ensure opaque background */
        z-index: 50;
      }

      /* Class to toggle view */
      .show-chat .sidebar {
        display: none;
      }

      .show-chat .main-chat {
        display: flex;
      }

      #welcomeScreen {
        display: none !important;
      }

      /* Don't show welcome on mobile, just list */

      #mobileBackBtn {
        display: block;
      }

      .app-header {
        display: none;
      }

      /* Optional: hide main app header to save space? or keep it? Let's keep it but maybe smaller padding */
      .app-header {
        padding: 0.5rem 1rem;
      }

      .app-header span {
        font-size: 1.5rem;
        font-weight: 700;
        margin-left: 10px;
      }

      .logo-container {
        display: flex;
        align-items: center;
      }

      .logo-container img {
        width: 36px;
        height: 36px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
      }

      /* Adjust chat header */
      .chat-header {
        padding: 0 10px;
      }
    }

    /* New Search Results */
    #searchResults {
      position: absolute;
      width: 100%;
      background: #1e293b;
      /* Solid background for visibility */
      border: var(--glass-border);
      border-radius: 12px;
      margin-top: 5px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 2000;
      /* Ensure on top of everything */
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      display: none;
    }

    .search-result-item {
      padding: 10px;
      display: flex;
      align-items: center;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .search-result-item:hover {
      background: var(--item-hover-bg);
    }

    .search-result-item img {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 10px;
    }

    /* Stylish Request Cards */
    .request-card {
      background: rgba(255, 255, 255, 0.05);
      border: var(--border-elegant);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: transform 0.2s;
    }

    .request-card:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    /* DP Overlay */
    .dp-container {
      position: relative;
      width: 80px;
      height: 80px;
      margin-right: 16px;
    }

    .dp-container img {
      width: 100%;
      height: 100%;
      border-radius: 24px;
      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .dp-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .dp-container:hover .dp-overlay {
      opacity: 1;
    }

    .dp-overlay span {
      font-size: 1.5rem;
      color: white;
    }

    /* Call UI */
    #callOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .call-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.2);
      margin-bottom: 20px;
      box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
      }

      70% {
        box-shadow: 0 0 0 20px rgba(168, 85, 247, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(168, 85, 247, 0);
      }
    }

    .call-actions button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      font-size: 1.5rem;
      margin: 0 15px;
      border: none;
      display: flex;
      /* flex center */
      align-items: center;
      justify-content: center;
      transition: transform 0.2s;
    }

    .call-actions button:hover {
      transform: scale(1.1);
    }

    .btn-end {
      background: #ef4444;
      color: white;
    }

    .btn-mute {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .btn-accept {
      background: #22c55e;
      color: white;
    }

    /* Whiteboard Dashboard */
    .wb-dashboard {
      flex: 1;
      padding: 30px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .wb-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
    }

    .wb-card {
      background: rgba(255, 255, 255, 0.05);
      border: var(--border-elegant);
      border-radius: 16px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: all 0.2s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .wb-card:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
    }

    .wb-thumbnail {
      width: 100%;
      height: 120px;
      background: white;
      border-radius: 8px;
      object-fit: cover;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ccc;
      font-size: 2rem;
    }

    .wb-title {
      font-weight: 600;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .wb-date {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    /* Whiteboard UI (Standalone) */
    .wb-ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-gradient);
      z-index: 5000;
      display: flex;
      flex-direction: column;
    }

    .wb-header {
      height: 60px;
      background: var(--glass-header-bg);
      backdrop-filter: blur(10px);
      border-bottom: var(--border-elegant);
      display: flex;
      align-items: center;
      padding: 0 20px;
      justify-content: space-between;
      color: var(--text-main);
    }

    .wb-header input {
      background: transparent;
      border: 1px solid transparent;
      color: var(--text-main);
      font-size: 1.2rem;
      font-weight: 600;
      width: 300px;
    }

    .wb-header input:focus {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.2);
    }

    .wb-toolbar {
      position: absolute;
      top: 80px;
      left: 20px;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(10px);
      border: var(--border-elegant);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }

    .wb-tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: transparent;
      color: var(--text-muted);
      border: 1px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }

    .wb-tool-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-main);
    }

    .wb-tool-btn.active {
      background: var(--primary-gradient);
      color: white;
      box-shadow: 0 4px 10px rgba(124, 58, 237, 0.4);
    }

    .wb-canvas-container {
      flex: 1;
      overflow: auto;
      background: #f1f5f9;
      /* Graph paper generic bg, or white */
      position: relative;
      cursor: crosshair;
    }

    body.light-mode .wb-canvas-container {
      background: #ffffff;
    }

    /* Shape Picker Popover */
    .wb-shape-picker {
      position: absolute;
      left: 60px;
      /* Right of toolbar */
      top: 0;
      width: 280px;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(20px);
      border: var(--border-elegant);
      border-radius: 12px;
      padding: 15px;
      display: none;
      /* Toggled */
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    .wb-shape-item {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .wb-shape-item svg {
      width: 24px;
      height: 24px;
      stroke: var(--text-main);
      fill: none;
      stroke-width: 2;
    }

    .wb-shape-item:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Auth Screens -->
    <div id="authScreen" class="auth-screen">
      <h2>Alter</h2>
      <div id="registerForm">
        <h3>Register</h3>
        <input type="text" id="regUsername" placeholder="Username" />
        <input type="email" id="regEmail" placeholder="Email" />
        <input type="password" id="regPassword" placeholder="Password" />
        <button onclick="register()">Register</button>
        <p><a href="#" onclick="showLogin()">Already have an account?</a></p>
      </div>
      <div id="loginForm" class="hidden">
        <h3>Login</h3>
        <input type="email" id="loginEmail" placeholder="Email" />
        <input type="password" id="loginPassword" placeholder="Password" />
        <button onclick="login()">Login</button>
        <p><a href="#" onclick="showRegister()">Need an account?</a></p>
      </div>
      <div id="otpForm" class="hidden">
        <h3>Verify OTP</h3>
        <p>Enter the 6-digit code sent to your email</p>
        <input type="text" id="otpCode" placeholder="123456" maxlength="6" />
        <button onclick="verifyOTP()">Verify</button>
        <p><a href="#" onclick="showRegister()">Change email?</a></p>
      </div>
    </div>

    <!-- Main App -->
    <div id="app" class="hidden" style="display:flex; flex-direction:column; height:100%;">
      <div class="app-header">
        <div class="logo-container">
          <img src="static/alter_logo.png" alt="Alter">
          <span>Alter</span>
        </div>
        <div>
          <button onclick="showCreateGroup()" style="font-size:0.9em;padding:6px 10px;margin-right:5px;">+
            Group</button>
          <button onclick="showSettings()" style="font-size:0.9em;padding:6px 10px;margin-right:5px;">Settings</button>
          <button onclick="logout()" style="font-size:0.9em;padding:6px 10px;">Logout</button>
        </div>
      </div>

      <div class="layout-wrapper">
        <div id="sidebar" class="sidebar">
          <div style="padding:10px;">
            <button onclick="showAddFriend()">+ Add Friend</button>
          </div>
          <div style="padding:0 10px 10px 10px;">
            <button onclick="showWhiteboardDashboard()">üé® Whiteboard</button>
          </div>
          <h4 style="padding:10px 16px;margin:0;">Chats</h4>
          <ul id="chatList" class="chat-list"></ul>
          <h4 style="padding:10px 16px;margin:0;">Groups</h4>
          <ul id="groupList" class="chat-list" style="flex:1;"></ul> <!-- Ensure this takes space if empty -->
          <div id="incomingRequests"></div>
        </div>

        <div id="chatArea" class="main-chat hidden">
          <div id="chat-background"></div>
          <div id="chatHeader" class="chat-header">
            <button id="mobileBackBtn" onclick="backToSidebar()">‚Üê</button>
            <input type="file" id="dpUpload" hidden onchange="uploadDP(this)" />
            <button onclick="document.getElementById('dpUpload').click()">Change DP</button>
            <button id="staticChangeGroupDpBtn" class="hidden"
              onclick="document.getElementById('groupIconUpload').click()">Group Icon (Sigma)</button>
            <div style="display:flex;align-items:center;gap:10px;">
              <img id="chatDp" class="dp" />
              <span>Select a chat</span>
            </div>
            <div class="chat-actions">
              <button id="callBtn" class="hidden" onclick="startCall()" title="Call">üìû</button>
              <button id="whiteboardBtn" class="hidden" onclick="openWhiteboard()" title="Collaborate">üé®</button>
              <button id="deleteChatBtn" class="hidden" onclick="deleteCurrentChat()" title="Delete Chat">üóë</button>
              <button id="deleteGroupBtn" class="hidden" onclick="deleteCurrentGroup()" title="Delete Group">üóë</button>
              <button id="groupMembersBtn" class="hidden" onclick="showGroupMembers()" title="Members">üë•</button>
              <input type="file" id="groupIconUpload" hidden onchange="uploadGroupIcon(this)" />
            </div>
          </div>
          <div id="messages" class="messages"></div>
          <div class="input-area">
            <select id="msgTimer" style="margin-right:5px;padding:10px;border-radius:20px;border:1px solid #ccc;">
              <option value="">Off</option>
              <option value="10">10s</option>
              <option value="60">1m</option>
              <option value="300">5m</option>
              <option value="3600">1h</option>
            </select>
            <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)" />
            <button onclick="sendMessage()">Send</button>
            <button onclick="document.getElementById('imageUpload').click()" style="margin-left:5px;">üì∑</button>
            <input type="file" id="imageUpload" accept="image/*" onchange="uploadImage(this)" style="display:none;" />
          </div>
        </div>

        <!-- Whiteboard Dashboard -->
        <div id="whiteboardDashboard" class="wb-dashboard hidden">
          <h2 style="margin-bottom:20px;">My Whiteboards</h2>
          <div style="margin-bottom:20px;">
            <button onclick="createNewWhiteboard()"
              style="background:var(--primary-gradient); color:white; padding:10px 20px; border-radius:30px; font-weight:600;">+
              New Whiteboard</button>
          </div>
          <div id="wbGrid" class="wb-grid">
            <!-- WB Cards loaded via JS -->
          </div>
        </div>

        <!-- Welcome Screen (When no chat selected) -->
        <div id="welcomeScreen"
          style="flex:1; display:flex; justify-content:center; align-items:center; color:#888; background:rgba(255,255,255,0.5);">
          <div style="text-align:center;">
            <div style="font-size:3rem; margin-bottom:1rem;">üëã</div>
            <h2>Welcome to Alter</h2>
            <p>Select a chat to start messaging</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Modals -->
    <div id="addFriendModal" class="hidden modal">
      <div class="modal-content">
        <h3>Add Friend</h3>
        <div style="position:relative;">
          <input type="text" id="friendUsername" placeholder="Enter username..." style="width:100%; margin-bottom: 5px;"
            oninput="searchUsers(this.value)" autocomplete="off" />
          <div id="searchResults"></div>
        </div>
        <div style="margin-top:20px; display: flex; gap: 10px;">
          <button onclick="sendFriendRequest()" style="flex:1;">Send Request</button>
          <button onclick="hideAddFriend()" class="secondary-btn" style="flex:1;">Cancel</button>
        </div>
      </div>
    </div>

    <div id="createGroupModal" class="hidden modal">
      <div class="modal-content">
        <h3>Create Group</h3>
        <input type="text" id="groupName" placeholder="Group name" style="width:100%; margin-bottom: 10px;" />
        <label style="display:block; margin-bottom:5px; color:var(--text-muted); font-size:0.9rem;">Select
          Friends:</label>
        <div class="member-list" id="friendSelectionList"
          style="max-height: 200px; margin-bottom: 20px; overflow-y: auto;"></div>
        <div style="display: flex; gap: 10px;">
          <button onclick="createGroup()" style="flex:1;">Create</button>
          <button onclick="hideCreateGroup()" class="secondary-btn" style="flex:1;">Cancel</button>
        </div>
      </div>
    </div>

    <div id="groupMembersModal" class="hidden modal">
      <div class="modal-content">
        <h3>Group Members</h3>
        <div class="member-list" id="groupMembersList"></div>
        <div style="margin-top:20px; display:flex; gap:10px;">
          <button id="addMemberBtn" onclick="showAddMemberModal()" style="flex:1;" class="hidden">Add Member</button>
          <button onclick="hideGroupMembers()" class="secondary-btn" style="flex:1;">Close</button>
        </div>
      </div>
    </div>

    <div id="addMemberModal" class="hidden modal" style="z-index: 1100;"> <!-- Higher z-index -->
      <div class="modal-content">
        <h3>Add Member</h3>
        <div class="member-list" id="addMemberFriendList" style="max-height: 200px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('addMemberModal').classList.add('hidden')" class="secondary-btn"
            style="width:100%;">Cancel</button>
        </div>
      </div>
    </div>



    <div id="reactionDetailsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Reactions</h3>
        <div class="member-list" id="reactionDetailsList" style="max-height: 300px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('reactionDetailsModal').classList.add('hidden')"
            class="secondary-btn" style="width:100%;">Close</button>
        </div>
      </div>
    </div>

    <div id="seenDetailsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Seen By</h3>
        <div class="member-list" id="seenDetailsList" style="max-height: 300px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('seenDetailsModal').classList.add('hidden')" class="secondary-btn"
            style="width:100%;">Close</button>
        </div>
      </div>
    </div>

    <!-- ... existing modals ... -->
    <div id="settingsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Settings</h3>
        <div style="display:flex;align-items:center;margin-bottom:20px;">
          <div class="dp-container" onclick="document.getElementById('settingsDpUpload').click()">
            <img id="settingsDp" class="dp" src="https://ui-avatars.com/api/?name=User" />
            <div class="dp-overlay"><span>üì∑</span></div>
          </div>
          <div>
            <h4 id="settingsUsernameDisplay" style="margin:0; font-size:1.2rem;">User</h4>
            <span style="font-size:0.8rem; color:var(--text-muted);">Click image to change</span>
            <input type="file" id="settingsDpUpload" hidden onchange="uploadSettingsDP(this)" />
          </div>
        </div>
        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Username</label>
        <input type="text" id="settingsUsername" disabled style="margin-bottom:15px; opacity:0.7;" />
        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Email</label>
        <input type="text" id="settingsEmail" disabled style="margin-bottom:15px; opacity:0.7;" />

        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <label style="color:var(--text-muted);">Appearance</label>
          <button id="themeToggleBtn" onclick="toggleTheme()" style="width:auto; padding:6px 12px; font-size:0.9rem;">‚òÄÔ∏è
            Light Mode</button>
        </div>

        <label style="display:block; margin-bottom:10px; color:var(--text-muted);">Chat Wallpaper</label>
        <div class="theme-grid">
          <div class="theme-option" onclick="selectTheme('default')" data-theme="default" title="Default (None)"
            style="background:var(--bg-gradient); display:flex;align-items:center;justify-content:center;">üö´</div>
          <div class="theme-option" onclick="selectTheme('bg1')" data-theme="bg1" title="Background 1"
            style="background-image:url('static/bg1.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg2')" data-theme="bg2" title="Background 2"
            style="background-image:url('static/bg2.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg3')" data-theme="bg3" title="Background 3"
            style="background-image:url('static/bg3.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg4')" data-theme="bg4" title="Background 4"
            style="background-image:url('static/bg4.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg5')" data-theme="bg5" title="Background 5"
            style="background-image:url('static/bg5.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg6')" data-theme="bg6" title="Background 6"
            style="background-image:url('static/bg6.png');"></div>
        </div>

        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Description (About)</label>
        <input type="text" id="settingsDescription" placeholder="Hey there! I am using Alter."
          style="margin-bottom:20px;" />
        <div style="display: flex; gap: 10px;">
          <button onclick="updateProfileDescription()" style="flex:1;">Save</button>
          <button onclick="hideSettings()" class="secondary-btn" style="flex:1;">Close</button>
        </div>
      </div>
    </div>
  </div>




  <div id="emojiPicker"></div>

  <!-- Audio Elements -->
  <audio id="remoteAudio" autoplay playsinline controls style="width:0;height:0;opacity:0;position:absolute;"></audio>
  <audio id="ringtone" src="https://assets.mixkit.co/active_storage/sfx/1359/1359-preview.mp3" loop></audio>

  <!-- Incoming Call Modal -->
  <div id="incomingCallModal" class="hidden modal" style="z-index: 2500;">
    <div class="modal-content" style="text-align:center;">
      <h3 id="incomingCallerName">Unknown</h3>
      <p>is calling you...</p>
      <div style="margin-top:20px; display:flex; justify-content:center; gap:20px;">
        <button onclick="acceptCall()"
          style="background:#22c55e; color:white; padding:15px 30px; border-radius:30px; font-size:1.1rem;">Accept</button>
        <button onclick="rejectCall()"
          style="background:#ef4444; color:white; padding:15px 30px; border-radius:30px; font-size:1.1rem;">Reject</button>
      </div>
    </div>
  </div>

  <!-- In-Call Overlay -->
  <div id="callOverlay" class="hidden">
    <img id="callAvatar" class="call-avatar" src="https://ui-avatars.com/api/?name=User" />
    <h3 id="callName" style="color:white; font-size:2rem; margin-bottom:10px;">User</h3>
    <p id="callStatus" style="color:#aaa; margin-bottom:30px;">Connected</p>

    <!-- Audio Helper -->
    <div id="audioHelper" class="hidden"
      style="position:absolute; top:20px; left:50%; transform:translateX(-50%); z-index:3000;">
      <button onclick="forcePlayAudio()"
        style="background:#ef4444; color:white; padding:10px 20px; border-radius:30px; border:2px solid white; font-weight:bold; box-shadow:0 4px 12px rgba(0,0,0,0.5); animation: pulse 2s infinite;">
        üîá TAP TO UNMUTE AUDIO
      </button>
    </div>

    <div class="call-actions">
      <button id="mainMuteBtn" class="btn-mute" onclick="toggleMute()">üé§</button>
      <button class="btn-screen" onclick="startScreenShare()"
        style="background:rgba(255,255,255,0.2);color:white;">üñ•Ô∏è</button>
      <button onclick="minimizeCall()"
        style="background:rgba(255,255,255,0.2); color:white; border-radius:50%; width:60px; height:60px; font-size:1.5rem; border:none; transition:transform 0.2s; display:flex; align-items:center; justify-content:center;">üîΩ</button>
      <button class="btn-end" onclick="endCall()">üìû</button>
    </div>

    <!-- Video Element for Screen Share -->
    <video id="remoteVideo" autoplay playsinline
      style="max-width:90%; max-height:60vh; border-radius:12px; margin-top:20px; display:none; border:2px solid rgba(255,255,255,0.2);"></video>
  </div>

  <!-- Mini Call Widget -->
  <div id="miniCallWidget" class="hidden"
    style="position:fixed; bottom:20px; right:20px; background:#1e293b; border:1px solid rgba(255,255,255,0.2); border-radius:16px; padding:10px 20px; display:flex; align-items:center; gap:15px; z-index:4000; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
    <div
      style="width:40px; height:40px; border-radius:50%; background:var(--primary-gradient); display:flex; align-items:center; justify-content:center; animation:pulse 2s infinite;">
      üìû</div>
    <div style="display:flex; flex-direction:column;">
      <span style="font-weight:bold; font-size:0.9rem; color:white;" id="miniCallName">User</span>
      <span style="font-size:0.75rem; color:#4ade80;">Active Call</span>
    </div>
    <div style="display:flex; gap:10px; margin-left:10px;">
      <button onclick="maximizeCall()"
        style="background:rgba(255,255,255,0.1); border:none; color:white; border-radius:50%; width:36px; height:36px;">‚§¢</button>
      <button id="miniMuteBtn" onclick="toggleMute()"
        style="background:rgba(255,255,255,0.1); border:none; color:white; border-radius:50%; width:36px; height:36px;">üé§</button>
      <button onclick="endCall()"
        style="background:#ef4444; width:36px; height:36px; border-radius:50%; color:white; border:none; display:flex; align-items:center; justify-content:center;">‚úñ</button>
    </div>
  </div>

  <!-- Whiteboard UI (Standalone) -->
  <div id="whiteboardUI" class="wb-ui hidden">
    <div class="wb-header">
      <input type="text" id="wbTitle" value="Untitled Whiteboard" onchange="saveWhiteboardName()">
      <div style="display:flex; gap:10px; align-items:center;">
        <span id="wbSaveStatus" style="font-size:0.8rem; color:var(--text-muted);">Saved</span>
        <button onclick="saveWhiteboard()"
          style="background:var(--primary-gradient); color:white; padding:8px 20px; border-radius:20px;">Save</button>
        <button onclick="closeWhiteboardUI()" class="secondary-btn">Close</button>
      </div>
    </div>

    <!-- Toolbar -->
    <div class="wb-toolbar">
      <button class="wb-tool-btn active" id="tool-pen" onclick="setTool('pen')" title="Pen">‚úèÔ∏è</button>
      <button class="wb-tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Eraser">üßπ</button>
      <button class="wb-tool-btn" id="tool-text" onclick="setTool('text')" title="Text">T</button>
      <button class="wb-tool-btn" id="tool-shapes" onclick="toggleShapePicker()" title="Shapes">üî∂</button>

      <div style="height:1px; background:rgba(255,255,255,0.1); margin:5px 0;"></div>

      <input type="color" id="wbColorPicker" value="#000000" onchange="setColor(this.value)"
        style="width:30px; height:30px; padding:0; border:none; border-radius:50%; overflow:hidden;">
      <input type="range" id="wbSizeSlider" min="1" max="20" value="4" oninput="setSize(this.value)"
        style="width:100%;">

      <!-- Shape Picker Popover -->
      <div id="wbShapePicker" class="wb-shape-picker">
        <!-- Shapes injected by JS -->
      </div>
    </div>

    <div class="wb-canvas-container" id="wbCanvasContainer">
      <canvas id="wbCanvasNew"></canvas>
    </div>
  </div>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // ... existing ...

    // Add force play function globally
    function forcePlayAudio() {
      const aud = document.getElementById('remoteAudio');
      if (aud) {
        aud.play().then(() => {
          document.getElementById('audioHelper').classList.add('hidden');
          console.log("Audio started manually");
        }).catch(e => alert("Still cannot play audio: " + e.message));
      }
    }

    // ... (rest of code) ...

    // Updated createPeerConnection function (Need to replace the old one lower down)


    function formatTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    async function showSeenDetails(messageId) {
      try {
        const list = document.getElementById('seenDetailsList');
        list.innerHTML = 'Loading...';
        document.getElementById('seenDetailsModal').classList.remove('hidden');

        const records = await api(`/messages/${messageId}/seen`);
        list.innerHTML = '';

        if (records.length === 0) {
          list.innerHTML = '<div style="padding:10px;text-align:center;color:#888">No views yet</div>';
          return;
        }

        records.forEach(r => {
          const div = document.createElement('div');
          div.className = 'chat-item';
          div.style.cursor = 'default';
          div.innerHTML = `
                   <img src="${avatar(r.profile_image, r.username)}" class="dp">
                   <div style="flex:1;">
                       <span style="font-weight:600;">${r.username}</span>
                       <div style="font-size:0.8rem;color:#888;">${formatTime(r.seen_at)}</div>
                   </div>
                `;
          list.appendChild(div);
        });
      } catch (e) {
        alert("Failed to load: " + e.message);
      }
    }


    // Config
    const API_BASE = window.location.origin;


    let currentUser = null;
    let currentChatId = null;
    let currentChatType = null; // 'private' or 'group'
    let socket = null;
    const EMOJIS = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üò°', 'üëè', 'üôè', 'üî•', 'üíØ'];

    // DOM Elements
    const authScreen = document.getElementById('authScreen');
    const app = document.getElementById('app');
    const registerForm = document.getElementById('registerForm');
    const loginForm = document.getElementById('loginForm');
    const otpForm = document.getElementById('otpForm');
    const chatList = document.getElementById('chatList');
    const groupList = document.getElementById('groupList');
    const incomingRequests = document.getElementById('incomingRequests');
    const chatArea = document.getElementById('chatArea');
    const chatHeader = document.getElementById('chatHeader');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const emojiPicker = document.getElementById('emojiPicker');
    const groupMembersBtn = document.getElementById('groupMembersBtn');
    const deleteChatBtn = document.getElementById('deleteChatBtn');
    const deleteGroupBtn = document.getElementById('deleteGroupBtn');

    // Selected friends for group creation
    let selectedFriendIds = [];

    // Auth UI Helpers
    function showRegister() {
      registerForm.classList.remove('hidden');
      loginForm.classList.add('hidden');
      otpForm.classList.add('hidden');
    }
    function showLogin() {
      loginForm.classList.remove('hidden');
      registerForm.classList.add('hidden');
      otpForm.classList.add('hidden');
    }
    function showOTP() {
      otpForm.classList.remove('hidden');
      registerForm.classList.add('hidden');
      loginForm.classList.add('hidden');
    }

    function avatar(url, name = "User") {
      return url || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=128C7E&color=fff`;
    }

    async function api(endpoint, options = {}) {
      const token = localStorage.getItem('token');
      const headers = { 'Content-Type': 'application/json', ...(options.headers || {}) };

      // Determine if this is a public endpoint that doesn't need auth
      const publicEndpoints = ['/login', '/register', '/verify-otp'];
      const cleanEndpoint = endpoint.split('?')[0]; // Ignore query params for check

      if (token && !publicEndpoints.includes(cleanEndpoint)) {
        headers['Authorization'] = `Bearer ${token}`;
        // console.log(`Attaching token for ${endpoint}`);
      } else {
        // console.log(`Skipping token for ${endpoint} (Public or No Token)`);
      }

      console.log(`API Call to ${endpoint}`, { hasToken: !!token, headers });
      const res = await fetch(API_BASE + endpoint, { ...options, headers });
      if (!res.ok) {
        let errMsg = 'Request failed';
        try {
          const err = await res.json();
          errMsg = err.msg || errMsg;
          if (res.status === 401 && errMsg === 'Token has expired') {
            logout(); // Auto logout on expire
            return;
          }
        } catch (e) { }
        throw new Error(errMsg);
      }
      return res.json();
    }

    async function deleteCurrentGroup() {
      if (!currentChatId || currentChatType !== 'group') return;
      if (!confirm("Delete this group permanently?")) return;
      try {
        await api(`/groups/${currentChatId}/delete`, { method: 'DELETE' });
        document.getElementById('welcomeScreen').classList.remove('hidden'); // Show welcome
        chatArea.classList.add('hidden');
        currentChatId = null;
        currentChatType = null;
        loadGroups();
        chatHeader.querySelector('span').textContent = 'Select a chat';
        deleteGroupBtn.classList.add('hidden');
        groupMembersBtn.classList.add('hidden');
        alert("Group deleted");
      } catch (e) {
        alert("Delete failed: " + e.message);
      }
    }

    // Auth Functions
    async function register() {
      const username = document.getElementById('regUsername').value;
      const email = document.getElementById('regEmail').value;
      const password = document.getElementById('regPassword').value;
      try {
        const data = await api('/register', { method: 'POST', body: JSON.stringify({ username, email, password }) });

        if (data.msg && data.msg.includes('verified automatically')) {
          alert('Registration successful! You have been verified automatically.');
          showLogin();
        } else {
          alert('Registration successful! Check your email for OTP.');
          showOTP();
        }
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }

    async function verifyOTP() {
      const email = document.getElementById('regEmail').value;
      const otp = document.getElementById('otpCode').value;
      try {
        await api('/verify-otp', { method: 'POST', body: JSON.stringify({ email, otp }) });
        alert('OTP verified! You can now log in.');
        showLogin();
      } catch (e) {
        alert('Invalid OTP: ' + e.message);
      }
    }

    async function login() {
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      try {
        const data = await api('/login', { method: 'POST', body: JSON.stringify({ email, password }) });
        if (!data.access_token) {
          alert('Server did not return a token.');
          return;
        }
        localStorage.setItem('token', data.access_token);
        initApp();
      } catch (e) {
        alert('Login failed: ' + e.message);
      }
    }

    async function initApp() {
      const token = localStorage.getItem('token');
      if (!token || token === 'undefined' || token === 'null') {
        localStorage.removeItem('token');
        return showLogin();
      }
      try {
        const profile = await api('/profile');
        currentUser = profile;
        authScreen.classList.add('hidden');
        app.classList.remove('hidden');
        connectSocket(token);
        loadChats();
        loadGroups();
        loadIncomingRequests();
      } catch (e) {
        console.error("Profile error:", e.message);
        localStorage.removeItem('token');
        showLogin();
      }
    }

    function logout() {
      localStorage.removeItem('token');
      if (socket) socket.disconnect();
      authScreen.classList.remove('hidden');
      app.classList.add('hidden');
      showLogin();
    }

    // Socket.IO
    function connectSocket(token) {
      socket = io(window.location.origin, { query: { token }, transports: ['websocket'] });

      socket.on('connect', () => console.log('Socket connected'));
      socket.on('new_message', addMessageToUI);
      socket.on('new_group_message', addMessageToUI);
      socket.on('reaction_update', (data) => {
        // console.log("Socket: reaction_update received:", data);
        updateReactionsUI(data.message_id, data.reactions);
      });
      socket.on('message_seen_update', (data) => {
        updateSeenUI(data.message_id, data.username);
      });
      socket.on('error', (data) => alert('Socket error: ' + data.msg));

      setupCallSocketListeners();
    }

    // Seen Observer
    const seenObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const msgIdStr = entry.target.id.replace('msg-', '');
          const msgId = parseInt(msgIdStr);

          // If it's my own message, I don't "see" it typically, or duplicates.
          // Simple logic: just emit mark_seen
          if (!isNaN(msgId) && socket && currentUser) {
            if (entry.target.dataset.senderId != currentUser.id) {
              // Only mark others' messages as seen
              // console.log("Marking seen:", msgId);
              socket.emit('mark_seen', { message_id: msgId });
              seenObserver.unobserve(entry.target); // Only mark once
            }
          }
        }
      });
    }, { threshold: 0.5 });

    // Load Chats and Groups
    async function loadChats() {
      const friends = await api('/friends');
      chatList.innerHTML = '';
      friends.forEach(friend => {
        const li = document.createElement('li');
        li.className = 'chat-item';
        li.innerHTML = `
          <img src="${avatar(friend.profile_image, friend.username)}" class="dp">
          <span>${friend.username}</span>
        `;
        li.onclick = () => openPrivateChat(friend.id, friend.username, friend.profile_image);
        chatList.appendChild(li);
      });
    }

    async function loadGroups() {
      try {
        const groups = await api('/groups');
        groupList.innerHTML = '';
        groups.forEach(group => {
          const li = document.createElement('li');
          li.className = 'chat-item';
          // Use group image or default
          const icon = group.image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(group.name)}&background=random`;
          li.innerHTML = `
             <img src="${icon}" class="dp">
             <span>${group.name}</span>
          `;
          li.onclick = () => openGroupChat(group.id, group.name, icon);
          groupList.appendChild(li);
        });
      } catch (e) {
        console.error("Error loading groups:", e);
      }
    }

    async function loadIncomingRequests() {
      try {
        const requests = await api('/friend-requests/incoming');
        incomingRequests.innerHTML = '';
        if (requests.length > 0) {
          const h4 = document.createElement('h4');
          h4.textContent = 'Friend Requests';
          h4.style.padding = '10px 16px';
          h4.style.margin = '0';
          incomingRequests.appendChild(h4);

          requests.forEach(req => {
            const div = document.createElement('div');
            div.className = 'request-card';
            div.innerHTML = `
               <div style="display:flex; align-items:center;">
                   <img src="${avatar(null, req.username)}" class="dp" style="width:32px;height:32px;border-radius:50%;margin-right:10px;">
                   <span style="font-weight:600;">${req.username}</span>
               </div>
               <div>
                   <button onclick="acceptRequest(${req.request_id})" style="background:none; border:none; color:green; font-size:1.2rem; cursor:pointer; padding:5px;">‚úî</button>
                   <button onclick="rejectRequest(${req.request_id})" style="background:none; border:none; color:red; font-size:1.2rem; cursor:pointer; padding:5px;">‚úñ</button>
               </div>
            `;
            incomingRequests.appendChild(div);
          });
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function acceptRequest(requestId) {
      await api(`/friend-requests/${requestId}/accept`, { method: 'POST' });
      loadIncomingRequests();
      loadChats();
    }

    async function rejectRequest(requestId) {
      await api(`/friend-requests/${requestId}/reject`, { method: 'POST' });
      loadIncomingRequests();
    }

    // Group Creation
    function showCreateGroup() {
      document.getElementById('createGroupModal').classList.remove('hidden');
      loadFriendsForGroup();
    }

    function hideCreateGroup() {
      document.getElementById('createGroupModal').classList.add('hidden');
      selectedFriendIds = [];
    }

    async function loadFriendsForGroup() {
      const friends = await api('/friends');
      const list = document.getElementById('friendSelectionList');
      list.innerHTML = '';
      selectedFriendIds = [];
      friends.forEach(friend => {
        const div = document.createElement('div');
        div.className = 'member-item'; // This color is fixed in CSS now
        div.textContent = friend.username;
        div.dataset.userId = friend.id;
        div.style.padding = "5px"; // Add some padding
        div.style.cursor = "pointer";
        div.onclick = toggleFriendSelection;
        list.appendChild(div);
      });
    }

    function toggleFriendSelection(e) {
      const userId = parseInt(e.target.dataset.userId);
      const index = selectedFriendIds.indexOf(userId);
      if (index === -1) {
        selectedFriendIds.push(userId);
        e.target.style.background = 'var(--primary-gradient)'; // Visual feedback
        e.target.style.color = 'white';
      } else {
        selectedFriendIds.splice(index, 1);
        e.target.style.background = 'transparent';
        e.target.style.color = 'var(--text-main)';
      }
    }

    async function createGroup() {
      const groupName = document.getElementById('groupName').value;
      if (!groupName) {
        alert('Please enter a group name');
        return;
      }
      try {
        await api('/groups/create', {
          method: 'POST',
          body: JSON.stringify({
            group_name: groupName,
            member_ids: selectedFriendIds
          })
        });
        alert('Group created successfully!');
        hideCreateGroup();
        loadGroups();
      } catch (e) {
        alert('Error creating group: ' + e.message);
      }
    }

    function backToSidebar() {
      document.querySelector('.layout-wrapper').classList.remove('show-chat');
      currentChatId = null;
      // Close any open whiteboard
      document.getElementById('whiteboardModal').classList.add('hidden');
    }

    // Chat Functions
    async function openPrivateChat(friendId, friendName, friendDp) {
      deleteChatBtn.classList.remove('hidden');
      document.getElementById('callBtn').classList.remove('hidden');
      document.getElementById('whiteboardBtn').classList.remove('hidden'); // Show WB
      deleteGroupBtn.classList.add('hidden');
      document.getElementById('staticChangeGroupDpBtn').classList.add('hidden');

      // Hide Welcome, Show Chat
      document.getElementById('welcomeScreen').classList.add('hidden');
      chatArea.classList.remove('hidden');

      // Mobile View Toggle
      document.querySelector('.layout-wrapper').classList.add('show-chat');

      try {
        // Fetch full profile to get Description (since friend list might be stale or simple)
        // Optimization: We could pass description from friend list click, but let's just fetch or use what we have.
        // For now, we update header with simple name.

        chatHeader.querySelector('span').innerHTML = `
            <div style="display:flex;flex-direction:column;">
                <span>${friendName}</span>
                <span id="headerStatus" style="font-size:0.75em;color:#666;font-weight:normal;"></span>
            </div>
        `;

        // Find friend in friend list to get description (avoids extra API call if we re-render friend list correctly)
        // But friend list isn't globally stored easily. Let's just rely on updated loadFriends?
        // Let's implement a quick fetch or just look at UI.
        // Better: openPrivateChat arguments are from click. Let's update arguments or fetch.
        // We will fetch /friends again to find this user or just accept it's missing until reload.

        const convData = await api(`/conversation-with/${friendId}`);
        currentChatId = convData.conversation_id;
        currentChatType = 'private';
        currentChatFriendId = friendId;


        document.getElementById('chatDp').src = avatar(friendDp, friendName);
        groupMembersBtn.classList.add('hidden');

        messagesDiv.innerHTML = '';

        // Fetch history
        const history = await api(`/chat/history/${currentChatId}`);
        messagesDiv.innerHTML = '';
        history.forEach(addMessageToUI);

        // Fetch Friend Details for Description update
        try {
          const friends = await api('/friends');
          const f = friends.find(u => u.id === friendId);
          if (f && f.description) {
            document.getElementById('headerStatus').textContent = f.description;
          }
        } catch (e) { }

        if (socket) {
          socket.emit('join_private_chat', { conversation_id: currentChatId });
        }
      } catch (e) {
        console.error("Error opening chat:", e);
        alert("Could not open chat: " + e.message);
      }
    }

    async function openGroupChat(id, name, iconUrl) {
      if (currentChatId === id && currentChatType === 'group') return;
      currentChatId = id;
      currentChatType = 'group';
      currentChatName = name;

      // Hide Welcome, Show Chat
      document.getElementById('welcomeScreen').classList.add('hidden');
      chatArea.classList.remove('hidden');

      // Mobile View Toggle
      document.querySelector('.layout-wrapper').classList.add('show-chat');


      // Reset UI
      document.getElementById('chatDp').src = iconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random`;
      document.getElementById('chatDp').parentElement.querySelector('span').textContent = name;
      messagesDiv.innerHTML = '';

      // Admin check for DP upload
      try {
        const members = await api(`/groups/${id}/members`);
        // Backend returns "id" for user id in this route
        const myMember = members.find(m => m.id === currentUser.id);
        const isAdmin = myMember && myMember.role === 'admin';

        if (isAdmin) {
          document.getElementById('staticChangeGroupDpBtn').classList.remove('hidden');
        } else {
          document.getElementById('staticChangeGroupDpBtn').classList.add('hidden');
        }
      } catch (e) { console.error(e); }

      document.getElementById('deleteChatBtn').classList.add('hidden');
      document.getElementById('callBtn').classList.add('hidden'); // Hide Call Button in Group
      document.getElementById('whiteboardBtn').classList.remove('hidden'); // Show WB for Groups too!
      document.getElementById('deleteGroupBtn').classList.remove('hidden');
      document.getElementById('groupMembersBtn').classList.remove('hidden');

      socket.emit('join_group_chat', { group_id: id });
      loadGroupHistory(id);
    }

    async function uploadGroupIcon(input) {
      const file = input.files[0];
      if (!file || currentChatType !== 'group') return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      try {
        const res = await fetch(API_BASE + `/groups/${currentChatId}/upload-icon`, {
          method: "POST",
          headers: { Authorization: `Bearer ${token}` },
          body: form
        });
        if (res.ok) {
          alert("Group icon updated!");
          loadGroups(); // Refresh list
          // Update header logic would need reload or manual generic update
          const data = await res.json();
          document.getElementById('chatDp').src = data.url;
        } else {
          alert("Failed (Only Sigma admins can do this)");
        }
      } catch (e) { alert(e.message); }
    }

    async function loadGroupHistory(groupId) {
      try {
        const history = await api(`/group-chat/history/${groupId}`);
        messagesDiv.innerHTML = '';
        history.forEach(addMessageToUI);
        scrollToBottom();
      } catch (e) {
        console.error("Error loading group chat history:", e);
      }
    }

    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Settings
    function showSettings() {
      document.getElementById('settingsModal').classList.remove('hidden');
      document.getElementById('settingsUsername').value = currentUser.username;
      document.getElementById('settingsEmail').value = currentUser.email;
      document.getElementById('settingsDescription').value = currentUser.description || '';
      document.getElementById('settingsDp').src = avatar(currentUser.profile_image, currentUser.username);
      updateThemeBtn();
      updateThemeSelectionUI(); // Update UI for wallpaper selection
    }

    function hideSettings() {
      document.getElementById('settingsModal').classList.add('hidden');
    }

    async function updateProfileDescription() {
      const desc = document.getElementById('settingsDescription').value;
      try {
        await api('/profile/update', { method: 'POST', body: JSON.stringify({ description: desc }) });
        currentUser.description = desc;
        alert("Description updated!");
      } catch (e) { alert(e.message); }
    }

    async function uploadSettingsDP(input) {
      const file = input.files[0];
      if (!file) return;
      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        const res = await fetch(API_BASE + '/profile/upload-dp', {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
          body: formData
        });
        const data = await res.json();
        currentUser.profile_image = data.url;
        document.getElementById('settingsDp').src = data.url;
        alert("Profile picture updated!");
      } catch (e) {
        alert("Upload failed: " + e.message);
      }
    }

    // Group Members
    function showGroupMembers() {
      if (currentChatType !== 'group') return;
      document.getElementById('groupMembersModal').classList.remove('hidden');
      loadGroupMembers();
    }

    function hideGroupMembers() {
      document.getElementById('groupMembersModal').classList.add('hidden');
    }

    // Add Member Logic
    async function showAddMemberModal() {
      document.getElementById('addMemberModal').classList.remove('hidden');
      const friends = await api('/friends');
      const list = document.getElementById('addMemberFriendList');
      list.innerHTML = '';

      // Filter out existing members (Client-side optimization)
      // Ideally we fetch members first, but we can do it inside the loop or fetch fresh
      const members = await api(`/groups/${currentChatId}/members`);
      const memberIds = new Set(members.map(m => m.id));

      friends.forEach(friend => {
        if (memberIds.has(friend.id)) return;

        const div = document.createElement('div');
        div.className = 'member-item';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.innerHTML = `
                <span>${friend.username}</span>
                <button onclick="addMemberToGroup(${friend.id})" style="padding:4px 10px; font-size:0.8rem;">Add</button>
            `;
        list.appendChild(div);
      });

      if (list.children.length === 0) {
        list.innerHTML = '<div style="color:var(--text-muted); text-align:center; padding:10px;">No friends to add</div>';
      }
    }

    async function addMemberToGroup(userId) {
      try {
        await api(`/groups/${currentChatId}/add_member`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
        alert("Member added!");
        document.getElementById('addMemberModal').classList.add('hidden');
        loadGroupMembers(); // Refresh list
      } catch (e) {
        alert("Failed to add: " + e.message);
      }
    }

    async function loadGroupMembers() {
      try {
        const members = await api(`/groups/${currentChatId}/members`);
        const list = document.getElementById('groupMembersList');
        list.innerHTML = '';

        // Find my role to determine if I can kick/add
        const myMember = members.find(m => m.id === currentUser.id);
        const myRole = myMember ? myMember.role : 'member';

        // Show/Hide Add Button
        if (myRole === 'admin') {
          document.getElementById('addMemberBtn').classList.remove('hidden');
        } else {
          document.getElementById('addMemberBtn').classList.add('hidden');
        }

        members.forEach(member => {
          const div = document.createElement('div');
          div.className = 'member-item';
          div.style.display = 'flex';
          div.style.justifyContent = 'space-between';
          div.style.alignItems = 'center';
          div.style.color = "var(--text-main)"; // Ensure visible

          let actions = '';
          // Only show actions if I am admin and target is not me
          if (myRole === 'admin' && member.id !== currentUser.id) {
            if (member.role !== 'admin') {
              actions += `<button onclick="promoteMember(${member.id})" style="background:gold;color:black;padding:2px 6px;font-size:0.8em;margin-left:2px;">Promote</button>`;
            } else {
              actions += `<button onclick="demoteMember(${member.id})" style="background:orange;padding:2px 6px;font-size:0.8em;margin-left:2px;">Demote</button>`;
            }
            actions += `<button onclick="kickMember(${member.id})" style="background:red;color:white;padding:2px 6px;font-size:0.8em;margin-left:2px;">Kick</button>`;
          }

          const roleBadge = member.role === 'admin' ? '<span style="color:gold;font-weight:bold;margin-left:5px;">(Sigma)</span>' : '';
          const desc = member.description ? `<div style="font-size:0.75em;color:gray;">${member.description}</div>` : '';

          div.innerHTML = `
                <div style="display:flex;align-items:center;">
                    <img src="${avatar(member.custom_profile_image || member.profile_image, member.username)}" class="dp" style="width:32px;height:32px;margin-right:8px;">
                    <div>
                        <div style="font-weight:500;">${member.username} ${roleBadge}</div>
                        ${desc}
                    </div>
                </div>
                <div>${actions}</div>
            `;
          list.appendChild(div);
        });
      } catch (e) {
        console.error("Error loading group members:", e);
      }
    }

    async function kickMember(userId) {
      if (!confirm("Kick user?")) return;
      await api(`/groups/${currentChatId}/kick`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }
    async function promoteMember(userId) {
      await api(`/groups/${currentChatId}/promote`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }
    async function demoteMember(userId) {
      await api(`/groups/${currentChatId}/demote`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }

    // Contextual DP
    async function uploadDP(input) {
      const file = input.files[0];
      if (!file) return;
      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        // If inside chat, use contextual route
        if (currentChatId) {
          const type = currentChatType; // 'private' or 'group'
          const res = await fetch(API_BASE + `/chat/${type}/${currentChatId}/upload-dp`, {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: formData
          });
          const data = await res.json();
          document.getElementById('chatDp').src = data.url; // Update header immediately
          alert("Chat DP updated!");
        } else {
          // Global Profile DP (fallback logic if called from profile settings)
          const res = await fetch(API_BASE + '/profile/upload-dp', {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: formData
          });
          alert("Global DP updated!");
        }
      } catch (e) {
        alert("Upload failed: " + e.message);
      }
    }

    // Friends
    function showAddFriend() {
      document.getElementById('addFriendModal').classList.remove('hidden');
    }
    function hideAddFriend() {
      document.getElementById('addFriendModal').classList.add('hidden');
    }

    async function deleteCurrentChat() {
      if (!currentChatId || currentChatType !== 'private') return;
      if (!confirm("Delete this chat permanently?")) return;
      try {
        await api(`/chat/delete/${currentChatId}`, { method: 'DELETE' });

        document.getElementById('welcomeScreen').classList.remove('hidden'); // Show welcome
        chatArea.classList.add('hidden');

        currentChatId = null;
        currentChatType = null;
        loadChats();
        alert("Chat deleted");
      } catch (e) {
        alert("Delete failed: " + e.message);
      }
    }

    async function sendFriendRequest() {
      const username = document.getElementById('friendUsername').value;
      try {
        await api('/friend-requests/send', { method: 'POST', body: JSON.stringify({ username }) });
        alert('Friend request sent!');
        hideAddFriend();
        loadChats();
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }

    // Messaging
    let searchTimeout = null;
    async function searchUsers(query) {
      const resultsDiv = document.getElementById('searchResults');
      if (!query || query.length < 1) {
        resultsDiv.style.display = 'none';
        return;
      }

      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(async () => {
        try {
          const results = await api(`/users/search?q=${encodeURIComponent(query)}`);
          resultsDiv.innerHTML = '';
          if (results.length > 0) {
            resultsDiv.style.display = 'block';
            results.forEach(user => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.innerHTML = `
                            <img src="${avatar(user.profile_image, user.username)}">
                            <span>${user.username}</span>
                        `;
              div.onclick = () => {
                document.getElementById('friendUsername').value = user.username;
                resultsDiv.style.display = 'none';
              };
              resultsDiv.appendChild(div);
            });
          } else {
            resultsDiv.style.display = 'none';
          }
        } catch (e) {
          console.error("Search error", e);
        }
      }, 300); // 300ms debounce
    }

    async function uploadImage(input) {
      const file = input.files[0];
      if (!file) return;

      // 1. Optimistic UI
      const tempId = 'temp_' + Date.now();
      const reader = new FileReader();
      reader.onload = function (e) {
        const base64 = e.target.result;
        // Add optimistic message
        addMessageToUI({
          id: tempId,
          client_temp_id: tempId,
          sender_id: currentUser.id,
          sender_name: currentUser.username,
          sender_dp: currentUser.profile_image,
          image_url: base64, // Display local base64
          timestamp: new Date().toISOString(),
          reactions: {},
          pending: true
        });
      };
      reader.readAsDataURL(file);

      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        const res = await fetch(API_BASE + '/upload-image', {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
          body: formData
        });
        const data = await res.json();

        if (!res.ok) throw new Error(data.msg || "Server Error");

        // 2. Send Real Message
        if (socket && currentChatId) {
          if (currentChatType === 'private') {
            socket.emit('send_message', {
              conversation_id: currentChatId,
              image_url: data.url,
              lifespan: document.getElementById('msgTimer').value || null,
              client_temp_id: tempId
            });
          } else if (currentChatType === 'group') {
            socket.emit('send_message', {
              group_id: currentChatId,
              image_url: data.url,
              lifespan: document.getElementById('msgTimer').value || null,
              client_temp_id: tempId
            });
          }
        }
      } catch (e) {
        alert('Image upload failed: ' + e.message);
        // Remove optimistic message if failed
        const failDiv = document.getElementById(`msg-${tempId}`);
        if (failDiv) failDiv.remove();
      }
    }



    function addMessageToUI(msg) {
      if (
        (currentChatType === 'private' && msg.conversation_id && currentChatId !== msg.conversation_id) || // Wait, socket event might not have conv_id?
        // Actually socket room filtering handles this usually, but good to check.
        // However, msg object from backend might not have conv_id if we didn't add it in emit.
        // Let's trust logic for now.
        false
      ) return;

      // Handle Optimistic Replacement
      if (msg.client_temp_id) {
        const tempEl = document.getElementById(`msg-${msg.client_temp_id}`);
        if (tempEl) {
          tempEl.remove(); // Remove temporary, replace with finalized
        }
      }

      // Check duplicates (real ID)
      if (document.getElementById(`msg-${msg.id}`)) return;

      const div = document.createElement('div');
      const isMe = msg.sender_id === currentUser.id;

      // Add ID to div for replacement logic
      const elementId = msg.pending ? `msg-${msg.id}` : `msg-${msg.id}`;
      div.id = elementId;
      div.dataset.senderId = msg.sender_id;

      div.className = `message ${isMe ? 'user' : 'other'} ${msg.pending ? 'pending' : ''}`;

      // Avatar (Contextual if available) - ONLY show in Groups for others
      const dpUrl = msg.sender_dp;
      let contentHtml = '';

      if (currentChatType === 'group' && !isMe) {
        // In Group: Show small avatar + Name
        contentHtml += `
            <div style="display:flex; align-items:flex-start;">
                 <img src="${avatar(dpUrl, msg.sender_name)}" style="width:36px;height:36px;border-radius:50%;margin-right:8px;flex-shrink:0;">
                 <div>
                    <div class="sender-name">${msg.sender_name}</div>
                    ${msg.content ? `<div>${msg.content}</div>` : ''}
                    ${msg.image_url ? `<img src="${msg.image_url}" style="pointer-events:none;">` : ''}
                 </div>
            </div>
          `;
      } else {
        // Private Chat OR Me: Clean bubble
        contentHtml += `
            ${msg.content ? `<div>${msg.content}</div>` : ''}
            ${msg.image_url ? `<img src="${msg.image_url}" style="pointer-events:none;">` : ''}
          `;
      }

      // Seen Footer (Only for my messages)
      let seenHtml = '';
      if (isMe) {
        // Always show eye for my messages, clickable to see details
        // We don't show count here to keep it clean, or we can. User asked for "Eye"
        seenHtml = `<div class="seen-status clickable" onclick="event.stopPropagation(); showSeenDetails(${msg.id})">
              <span style="font-size:1.1rem;">üëÅ</span>
          </div>`;
      }

      const timeHtml = `<div class="msg-time">${formatTime(msg.timestamp)}</div>`;

      div.innerHTML = `
        ${contentHtml}
        ${timeHtml}
        <div class="reactions" id="reactions-${msg.id}"></div>
        <div class="seen-container" id="seen-${msg.id}"></div>
      `;

      // Append to DOM first
      messagesDiv.appendChild(div);

      // Add Seen Icon if Me
      if (isMe) {
        const seenContainer = document.getElementById(`seen-${msg.id}`);
        const eyeBtn = document.createElement('div');
        eyeBtn.className = 'seen-status clickable';
        eyeBtn.innerHTML = '<span style="font-size:1.1rem;">üëÅ</span>';
        eyeBtn.onclick = (e) => {
          e.stopPropagation(); // CRITICAL: Stop bubbling to message click
          console.log('Eye clicked', msg.id);
          showSeenDetails(msg.id);
        };
        seenContainer.appendChild(eyeBtn);
      }

      // Observe for read receipts - ONLY if it's NOT my message
      if (!isMe && !msg.pending) {
        seenObserver.observe(div);
      }

      updateReactionsUI(msg.id, msg.reactions);

      // On click (Single click) on the bubble itself
      div.onclick = (e) => {
        // Double check target is not reaction or eye (though stopPropagation should handle it)
        if (e.target.closest('.reaction') || e.target.closest('.seen-status')) return;
        showEmojiPicker(e, msg.id);
      };
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function updateSeenUI(messageId, username) {
      // Real-time update logic if needed
    }


    function sendMessage() {
      const content = messageInput.value.trim();
      const lifespan = document.getElementById('msgTimer').value || null;
      if (!content) return;

      if (socket && currentChatId) {
        const tempId = 'temp_' + Date.now();

        // 1. Optimistic UI
        addMessageToUI({
          id: tempId,
          client_temp_id: tempId,
          sender_id: currentUser.id,
          sender_name: currentUser.username,
          sender_dp: currentUser.profile_image,
          content: content,
          timestamp: new Date().toISOString(),
          reactions: {},
          pending: true
        });

        // 2. Emit
        const payload = { content, lifespan, client_temp_id: tempId };
        if (currentChatType === 'private') {
          payload.conversation_id = currentChatId;
        } else {
          payload.group_id = currentChatId;
        }
        socket.emit('send_message', payload);
        messageInput.value = '';
      }
    }

    function handleKeyPress(e) {
      if (e.key === 'Enter') sendMessage();
    }


    // MESSAGE RENDERING WITH REACTIONS
    function updateReactionsUI(messageId, reactions) {
      // console.log("updateReactionsUI called for msg:", messageId, reactions);
      const reactionsDiv = document.getElementById(`reactions-${messageId}`);
      if (!reactionsDiv) return;

      reactionsDiv.innerHTML = '';
      if (reactions && typeof reactions === 'object') {
        Object.entries(reactions).forEach(([emoji, count]) => {
          const span = document.createElement('span');
          span.className = 'reaction';
          span.textContent = `${emoji} ${count}`;
          span.style.cursor = 'pointer';
          span.onclick = (e) => {
            e.stopPropagation();
            showReactionDetails(messageId);
          };
          reactionsDiv.appendChild(span);
        });
      }
    }

    async function showReactionDetails(messageId) {
      try {
        const list = document.getElementById('reactionDetailsList');
        list.innerHTML = 'Loading...';
        document.getElementById('reactionDetailsModal').classList.remove('hidden');

        const reactions = await api(`/messages/${messageId}/reactions`);
        list.innerHTML = '';

        if (reactions.length === 0) {
          list.innerHTML = '<div style="padding:10px;text-align:center;color:#888">No reactions yet</div>';
          return;
        }

        reactions.forEach(r => {
          const div = document.createElement('div');
          div.className = 'chat-item';
          div.style.cursor = 'default';
          div.innerHTML = `
                   <img src="${avatar(r.profile_image, r.username)}" class="dp">
                   <div style="flex:1;">
                       <span style="font-weight:600;">${r.username}</span>
                   </div>
                   <span style="font-size:1.2rem;">${r.emoji}</span>
                `;
          list.appendChild(div);
        });
      } catch (e) {
        alert("Failed to load reactions: " + e.message);
      }
    }

    async function uploadDP(input) {
      const file = input.files[0];
      if (!file) return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      const res = await fetch(API_BASE + "/profile/upload-dp", {
        method: "POST",
        headers: { Authorization: `Bearer ${token}` },
        body: form
      });
      const data = await res.json();
      currentUser.profile_image = data.url;
      alert("Profile picture updated");
      loadChats();
    }

    async function uploadGroupIcon(input) {
      if (!currentChatId || currentChatType !== 'group') return;
      const file = input.files[0];
      if (!file) return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      try {
        const res = await fetch(API_BASE + `/groups/${currentChatId}/upload-icon`, {
          method: "POST",
          headers: { Authorization: `Bearer ${token}` },
          body: form
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.msg || "Server Error");

        document.getElementById('chatDp').src = data.url;
        alert("Group Icon (Sigma) updated!");
        loadChats(); // refresh sidebar to show new icon
      } catch (e) {
        alert("Failed (" + e.message + ")");
      }
    }



    function showEmojiPicker(e, messageId) {
      console.log("showEmojiPicker called for msg:", messageId);
      e.stopPropagation(); // Stop bubbling
      e.preventDefault();

      const msgElement = e.currentTarget; // The message div

      emojiPicker.innerHTML = '';
      EMOJIS.forEach(emoji => {
        const span = document.createElement('span');
        span.className = 'emoji';
        span.textContent = emoji;
        span.onclick = (evt) => {
          evt.stopPropagation();
          console.log("Emoji selected:", emoji);
          if (socket) {
            console.log("Emitting react:", { message_id: messageId, emoji });

            // 1. Optimistic UI Update
            const reactionsDiv = document.getElementById(`reactions-${messageId}`);
            if (reactionsDiv) {
              // Check if I already reacted? Handling that optimistically is complex without local state.
              // Simplified: Just increment count or append emoji locally for visual feedback
              // We'll rely on server broadcast for perfect accuracy, but showing "..." or immediate update is good.
              // Let's just optimistic increment.
              let found = false;
              for (let child of reactionsDiv.children) {
                if (child.textContent.includes(emoji)) {
                  const parts = child.textContent.split(' ');
                  const count = parseInt(parts[1]) + 1;
                  child.textContent = `${emoji} ${count}`;
                  found = true;
                  break;
                }
              }
              if (!found) {
                const span = document.createElement('span');
                span.className = 'reaction';
                span.textContent = `${emoji} 1`;
                reactionsDiv.appendChild(span);
              }
            }

            socket.emit('react', { message_id: messageId, emoji });
          } else {
            console.error("Socket not connected!");
            alert("Connection error: please refresh");
          }
          emojiPicker.style.display = 'none'; // Close after select
        };
        emojiPicker.appendChild(span);
      });

      // SMART POSITIONING LOGIC
      const rect = msgElement.getBoundingClientRect();
      const pickerHeight = 200; // Approx height
      const pickerWidth = 250;  // Approx width

      let left = rect.left;
      let top = rect.bottom + 5; // Default: below message

      // Check vertical overflow (bottom)
      if (top + pickerHeight > window.innerHeight) {
        top = rect.top - pickerHeight - 5; // Position above if no space below
      }

      // Check horizontal overflow (right)
      if (left + pickerWidth > window.innerWidth) {
        left = window.innerWidth - pickerWidth - 10; // Shift left if off screen
      }

      // Ensure not off-top (if message is very high up and we moved picker above)
      if (top < 0) {
        top = 10; // Force sticky to top
      }

      emojiPicker.style.left = `${left}px`;
      emojiPicker.style.top = `${top}px`;
      emojiPicker.style.display = 'grid'; // Make visible

      // One-time click outside listener
      const closePicker = (evt) => {
        if (!emojiPicker.contains(evt.target)) {
          emojiPicker.style.display = 'none';
          document.removeEventListener('click', closePicker);
        }
      };
      setTimeout(() => document.addEventListener('click', closePicker), 0);
    }



    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Theme Logic
    function toggleTheme() {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      updateThemeBtn();
      // Static themes work on top of light/dark mode, or replace background
      // For now, static themes are just backgrounds for chat area.
    }

    function updateThemeBtn() {
      const btn = document.getElementById('themeToggleBtn');
      if (btn) {
        const isLight = document.body.classList.contains('light-mode');
        btn.textContent = isLight ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
        btn.style.background = isLight ? '#0f172a' : 'var(--primary-gradient)';
        btn.style.color = isLight ? 'white' : 'white';
      }
    }

    // Static Wallpaper Logic
    let currentWallpaper = 'default';

    function selectTheme(themeName) {
      currentWallpaper = themeName;
      localStorage.setItem('chatWallpaper', themeName);
      applyWallpaper();
      updateThemeSelectionUI();
    }

    function applyWallpaper() {
      const bg = document.getElementById('chat-background');
      if (!bg) return;

      // Reset classes
      bg.className = '';

      // Apply new class
      if (currentWallpaper !== 'default') {
        bg.classList.add(`theme-${currentWallpaper}`);
      }
    }

    function updateThemeSelectionUI() {
      document.querySelectorAll('.theme-option').forEach(el => {
        if (el.dataset.theme === currentWallpaper) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }

    function initTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'light') {
        document.body.classList.add('light-mode');
      }

      const savedWallpaper = localStorage.getItem('chatWallpaper');
      if (savedWallpaper) {
        currentWallpaper = savedWallpaper;
      }
      applyWallpaper();
    }

    // Initialize Theme immediately
    initTheme();

    /* ================= WebRTC Audio Call Logic ================= */
    let localStream;
    let screenStream;
    let peerConnection;
    let candidateQueue = []; // Queue for ICE candidates
    // let currentChatFriendId = null; // Defined globally above or implicitly

    // 1. Optimize Connection Speed
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10 // Pre-gather candidates
    };

    // 2. Improve Audio Quality
    const audioConstraints = {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: { ideal: true }
    };

    // UI Helpers
    function showCallOverlay(name, dp) {
      document.getElementById('callOverlay').classList.remove('hidden');
      document.getElementById('callName').textContent = name;
      document.getElementById('callAvatar').src = avatar(dp, name);
      document.getElementById('callStatus').textContent = "Calling...";
    }

    function hideCallOverlay() {
      document.getElementById('callOverlay').classList.add('hidden');
      stopRingtone();
    }

    function playRingtone() {
      // user interaction required usually, but usually works if triggered by event
      document.getElementById('ringtone').play().catch(e => console.log("Audio play error", e));
    }
    function stopRingtone() {
      document.getElementById('ringtone').pause();
      document.getElementById('ringtone').currentTime = 0;
    }

    async function startCall() {
      if (!currentChatId || currentChatType !== 'private') {
        alert("Can only call in private chats.");
        return;
      }

      // Determine friend details
      const friendName = chatHeader.querySelector('span > div > span').textContent;
      const friendDp = document.getElementById('chatDp').src;

      showCallOverlay(friendName, friendDp);
      document.getElementById('callStatus').textContent = "Accessing Microphone...";

      try {
        // Check for devices first
        const devices = await navigator.mediaDevices.enumerateDevices();
        const hasMic = devices.some(d => d.kind === 'audioinput');
        if (!hasMic) {
          throw new Error("No microphone found. Please connect a headset.");
        }

        localStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints }); // Use optimized constraints
        createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        document.getElementById('callStatus').textContent = "Calling...";
        const offer = await peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }); // Explicit offer
        await peerConnection.setLocalDescription(offer);

        socket.emit('call_user', {
          user_to_call: currentChatFriendId,
          signal_data: offer,
          from: currentUser.id
        });

      } catch (e) {
        console.error("Call Error:", e);
        let msg = e.message;
        if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
          msg = "Microphone permission denied. Please allow access in browser settings.";
        } else if (e.name === 'NotFoundError' || e.name === 'DevicesNotFoundError') {
          msg = "Microphone not found.";
        }
        alert("Call Failed: " + msg);
        endCall();
      }
    }

    // Global to store who we are talking to
    // let currentChatFriendId is set in openPrivateChat

    function setupCallSocketListeners() {
      if (!socket) return;

      socket.on('incoming_call', async (data) => {
        // Handle Renegotiation (Screen Share update)
        if (peerConnection && currentChatFriendId === data.from) {
          console.log("Renegotiation offer received");
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));
          // Process queued candidates now that we have remote description
          while (candidateQueue.length > 0) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
          }
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer_call', { signal: answer, to: data.from });
          return;
        }

        if (peerConnection) return; // Busy

        // Show Modal
        document.getElementById('incomingCallModal').classList.remove('hidden');
        document.getElementById('incomingCallerName').textContent = "Incoming Call...";

        // Fetch caller name
        try {
          const friends = await api('/friends');
          const friend = friends.find(f => f.id === data.from);
          if (friend) document.getElementById('incomingCallerName').textContent = friend.username;
        } catch (e) { }

        playRingtone();
        window.incomingCallData = data;
      });

      socket.on('call_accepted', async (data) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));
        // Process queued candidates
        while (candidateQueue.length > 0) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
        }
        document.getElementById('callStatus').textContent = "Connected";
      });

      socket.on('ice_candidate', async (data) => {
        if (!peerConnection) return;

        // Queue candidates if remote description isn't set yet
        if (!peerConnection.remoteDescription) {
          console.log("Queueing ICE candidate (RemoteDesc not set)");
          candidateQueue.push(data.candidate);
        } else {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });

      socket.on('call_ended', () => {
        // Clear everything
        endCall(false);
        document.getElementById('incomingCallModal').classList.add('hidden'); // Force hide
        stopRingtone();
        // alert("Call Ended"); // Optional: less spammy if we remove alert
      });

      socket.on('call_answered_elsewhere', () => {
        document.getElementById('incomingCallModal').classList.add('hidden');
        stopRingtone();
      });

      // 3. Fix Screen Share Cache
      socket.on('stop_screen_share', () => {
        console.log("Remote screen share stopped");
        const vid = document.getElementById('remoteVideo');
        vid.srcObject = null; // Clear stream
        vid.style.display = 'none'; // Hide element
      });
    }

    // Call Actions
    async function acceptCall() {
      document.getElementById('incomingCallModal').classList.add('hidden');
      stopRingtone();
      const data = window.incomingCallData;

      showCallOverlay("Connected", null);
      document.getElementById('callStatus').textContent = "Connecting...";

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints }); // Use optimized constraints

        currentChatFriendId = data.from; // Set ID BEFORE creating PC to allow ICE candidates

        // FIX: Ensure conversation context is loaded for whiteboard sync & minimize visibility
        try {
          const convData = await api(`/conversation-with/${currentChatFriendId}`);
          currentChatId = convData.conversation_id;
          currentChatType = 'private'; // Calls are private only

          // Join socket room for WB events
          if (socket) socket.emit('join_private_chat', { conversation_id: currentChatId });

          // Optionally open chat in background? No, let minimize handle it if logical.
          // But setting currentChatId is CRITICAL for whiteboard.
        } catch (e) { console.error("Failed to load chat context for call:", e); }

        createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));

        // Process queued candidates
        while (candidateQueue.length > 0) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
        }

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit('answer_call', {
          signal: answer,
          to: data.from
        });

        document.getElementById('callStatus').textContent = "Connected";

      } catch (e) {
        console.error(e);
        endCall();
      }
    }

    function rejectCall() {
      document.getElementById('incomingCallModal').classList.add('hidden');
      stopRingtone();
      socket.emit('end_call', { to: window.incomingCallData.from });
    }

    function endCall(emitEvent = true) {
      hideCallOverlay();
      candidateQueue = []; // Clear queue
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      // Cleanup Mini Widget
      document.getElementById('miniCallWidget').classList.add('hidden');
      document.getElementById('callOverlay').classList.add('hidden'); // Ensure closed

      if (emitEvent && currentChatFriendId) {
        socket.emit('end_call', { to: currentChatFriendId });
      }
    }

    function toggleMute() {
      if (localStream) {
        const track = localStream.getAudioTracks()[0];
        track.enabled = !track.enabled;

        // Update UI
        const isMuted = !track.enabled;
        const mainBtn = document.getElementById('mainMuteBtn');
        const miniBtn = document.getElementById('miniMuteBtn');

        if (isMuted) {
          if (mainBtn) {
            mainBtn.style.background = '#ef4444';
            mainBtn.textContent = 'üîá';
          }
          if (miniBtn) {
            miniBtn.style.background = '#ef4444';
            miniBtn.textContent = 'üîá';
          }
        } else {
          if (mainBtn) {
            mainBtn.style.background = 'rgba(255,255,255,0.2)';
            mainBtn.textContent = 'üé§';
          }
          if (miniBtn) {
            miniBtn.style.background = 'rgba(255,255,255,0.1)';
            miniBtn.textContent = 'üé§';
          }
        }
      }
    }

    // Minimize/Maximize Call
    function minimizeCall() {
      document.getElementById('callOverlay').classList.add('hidden');
      document.getElementById('miniCallWidget').classList.remove('hidden');

      // Update name in widget
      const name = document.getElementById('callName').textContent;
      document.getElementById('miniCallName').textContent = name;

      // If not already in chat view (e.g. accepted from generic screen), maybe try to go to chat?
      if (currentChatId) {
        // If we have ID (set in acceptCall/startCall), ensure layout is correct
        document.querySelector('.layout-wrapper').classList.add('show-chat');
        document.getElementById('chatArea').classList.remove('hidden');
        document.getElementById('welcomeScreen').classList.add('hidden');

        // If chat content empty/stale, reload it?
        // openPrivateChat does UI setup, maybe call it?
        // But openPrivateChat does a lot of fetches.
        // If we just accepted call, currentChatId is set but UI might be blank.
        // Let's call openPrivateChat logic to be safe if content is empty?
        if (document.getElementById('messages').children.length === 0 && currentChatFriendId) {
          // Reuse openPrivateChat logic but with minimal disruption? 
          // Actually simpler: just let user navigate if they want.
          // But better UX: Show the chat they are talking in.

          // We need friend details... we have ID.
          // Search friend list for details
          const items = document.querySelectorAll('#chatList li');
          // This is messy. Let's just trust user or basic visibility.
        }
      }
    }

    function maximizeCall() {
      document.getElementById('callOverlay').classList.remove('hidden');
      document.getElementById('miniCallWidget').classList.add('hidden');
    }

    async function startScreenShare() {
      if (!peerConnection) {
        alert("You must be in a call to share screen.");
        return;
      }
      try {
        // OPTIMIZATION: Limit resolution and frame rate to reduce lag
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            cursor: "always",
            width: { max: 1280, ideal: 1280 },
            height: { max: 720, ideal: 720 },
            frameRate: { max: 15 } // Lower frame rate for smoother presentation
          },
          audio: false
        });
        const videoTrack = screenStream.getVideoTracks()[0];

        // Add to PC
        const sender = peerConnection.addTrack(videoTrack, localStream);

        // Handle Stop via browser UI
        videoTrack.onended = () => {
          stopScreenShare(sender);
        };

        // Negotiate
        forceRenegotiation();

        // UI update
        document.querySelector('.btn-screen').style.background = '#22c55e'; // Green

      } catch (e) {
        console.error("Screen Share Error", e);
        alert("Detailed error: " + e.message);
      }
    }

    function stopScreenShare(sender) {
      if (sender) {
        try { peerConnection.removeTrack(sender); } catch (e) { }
      }
      if (screenStream) {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }

      // Explicit Stop Signal
      if (socket && currentChatFriendId) {
        socket.emit('stop_screen_share', { to: currentChatFriendId });
      }

      // FORCE CLEAR VIDEO BUFFER (Fixes frozen frame)
      const vid = document.getElementById('remoteVideo');
      vid.pause();
      vid.removeAttribute('src'); // Remove src attribute
      vid.removeAttribute('srcObject'); // Remove srcObject
      vid.srcObject = null;
      vid.src = "";
      vid.load(); // Force reload to clear buffer
      vid.style.display = 'none';

      forceRenegotiation();
      document.querySelector('.btn-screen').style.background = 'rgba(255,255,255,0.2)';
    }

    async function forceRenegotiation() {
      try {
        const offer = await peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }); // Ensure audio offer persists
        await peerConnection.setLocalDescription(offer);
        socket.emit('call_user', {
          user_to_call: currentChatFriendId,
          signal_data: offer,
          from: currentUser.id
        });
      } catch (e) { console.error("Renegotiation failed", e); }
    }

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(rtcConfig);
      candidateQueue = []; // Reset queue for new connection

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && currentChatFriendId) {
          socket.emit('ice_candidate', {
            to: currentChatFriendId,
            candidate: event.candidate
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log("Connection State:", peerConnection.connectionState);
        const status = document.getElementById('callStatus');
        if (peerConnection.connectionState === 'connected') {
          status.textContent = "Connected (SECURE)";
          status.style.color = "#4ade80"; // Green
        } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
          status.textContent = "Reconnecting...";
          status.style.color = "#facc15"; // Yellow
        } else if (peerConnection.connectionState === 'closed') {
          status.textContent = "Call Ended";
        }
      };

      peerConnection.ontrack = (event) => {
        const stream = event.streams[0];
        if (event.track.kind === 'video') {
          console.log("Remote Video Track Received");
          const vid = document.getElementById('remoteVideo');
          vid.srcObject = stream;
          vid.style.display = 'block';
          vid.muted = true; // Mute video element to avoid audio echo (audio handled by remoteAudio)
          vid.play().catch(e => console.error("Video play failed", e));
        } else {
          console.log("Remote Audio Track Received");
          const aud = document.getElementById('remoteAudio');
          aud.srcObject = stream;
          aud.volume = 1.0; // Ensure max volume
          aud.muted = false; // Explicitly unmute

          // Try to play
          const playPromise = aud.play();
          if (playPromise !== undefined) {
            playPromise.then(_ => {
              console.log("Audio playing successfully");
            }).catch(e => {
              console.error("Audio play failed (Autoplay blocked?):", e);
              // Show helper UI
              document.getElementById('audioHelper').classList.remove('hidden');
            });
          }
        }
      };
    }

    // Legacy Whiteboard Logic Removed


    // Inject listener setup into connectSocket
    const originalConnect = connectSocket;
    connectSocket = function (token) {
      originalConnect(token); // Call original
      setupWhiteboardSocket(); // Add WB listeners
    };

    // Start
    if (localStorage.getItem('token')) {
      initApp();
    } else {
    }
  </script>
  <script>
    /* ================= Whiteboard Logic V2 (Standalone) ================= */

    // --- State & Constants ---
    const SHAPES = {
      'rect': { name: 'Rectangle', icon: '‚¨ú', path: (ctx, x, y, w, h) => ctx.rect(x, y, w, h) },
      'circle': { name: 'Circle', icon: '‚ö™', path: (ctx, x, y, w, h) => { ctx.arc(x + w / 2, y + h / 2, Math.abs(w) / 2, 0, 2 * Math.PI); } },
      'triangle': {
        name: 'Triangle', icon: 'üî∫', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w / 2, y); ctx.lineTo(x, y + h); ctx.lineTo(x + w, y + h); ctx.closePath();
        }
      },
      'star': {
        name: 'Star', icon: '‚≠ê', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, outer = Math.abs(w) / 2, inner = outer / 2;
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer);
            ctx.lineTo(cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner);
          }
          ctx.closePath();
        }
      },
      'arrow_r': {
        name: 'Arrow Right', icon: '‚û°Ô∏è', path: (ctx, x, y, w, h) => {
          const my = y + h / 2;
          ctx.moveTo(x, my - h / 4); ctx.lineTo(x + w * 0.7, my - h / 4); ctx.lineTo(x + w * 0.7, y);
          ctx.lineTo(x + w, my); ctx.lineTo(x + w * 0.7, y + h); ctx.lineTo(x + w * 0.7, my + h / 4);
          ctx.lineTo(x, my + h / 4); ctx.closePath();
        }
      },
      'arrow_l': {
        name: 'Arrow Left', icon: '‚¨ÖÔ∏è', path: (ctx, x, y, w, h) => {
          const my = y + h / 2;
          ctx.moveTo(x + w, my - h / 4); ctx.lineTo(x + w * 0.3, my - h / 4); ctx.lineTo(x + w * 0.3, y);
          ctx.lineTo(x, my); ctx.lineTo(x + w * 0.3, y + h); ctx.lineTo(x + w * 0.3, my + h / 4);
          ctx.lineTo(x + w, my + h / 4); ctx.closePath();
        }
      },
      'arrow_u': {
        name: 'Arrow Up', icon: '‚¨ÜÔ∏è', path: (ctx, x, y, w, h) => {
          const mx = x + w / 2;
          ctx.moveTo(mx - w / 4, y + h); ctx.lineTo(mx - w / 4, y + h * 0.3); ctx.lineTo(x, y + h * 0.3);
          ctx.lineTo(mx, y); ctx.lineTo(x + w, y + h * 0.3); ctx.lineTo(mx + w / 4, y + h * 0.3);
          ctx.lineTo(mx + w / 4, y + h); ctx.closePath();
        }
      },
      'arrow_d': {
        name: 'Arrow Down', icon: '‚¨áÔ∏è', path: (ctx, x, y, w, h) => {
          const mx = x + w / 2;
          ctx.moveTo(mx - w / 4, y); ctx.lineTo(mx - w / 4, y + h * 0.7); ctx.lineTo(x, y + h * 0.7);
          ctx.lineTo(mx, y + h); ctx.lineTo(x + w, y + h * 0.7); ctx.lineTo(mx + w / 4, y + h * 0.7);
          ctx.lineTo(mx + w / 4, y); ctx.closePath();
        }
      },
      'diamond': {
        name: 'Diamond', icon: 'üî∂', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w / 2, y); ctx.lineTo(x + w, y + h / 2); ctx.lineTo(x + w / 2, y + h); ctx.lineTo(x, y + h / 2); ctx.closePath();
        }
      },
      'cloud': {
        name: 'Cloud', icon: '‚òÅÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w * 0.2, y + h * 0.7, w * 0.2, 0, 2 * Math.PI);
          ctx.arc(x + w * 0.5, y + h * 0.6, w * 0.3, 0, 2 * Math.PI);
          ctx.arc(x + w * 0.8, y + h * 0.7, w * 0.2, 0, 2 * Math.PI);
        }
      },
      'heart': {
        name: 'Heart', icon: '‚ù§Ô∏è', path: (ctx, x, y, w, h) => {
          const topCurveHeight = h * 0.3;
          ctx.moveTo(x + w / 2, y + h * 0.2);
          ctx.bezierCurveTo(x + w / 2, y, x, y, x, y + topCurveHeight);
          ctx.bezierCurveTo(x, y + (h + topCurveHeight) / 2, x + w / 2, y + h, x + w / 2, y + h);
          ctx.bezierCurveTo(x + w / 2, y + h, x + w, y + (h + topCurveHeight) / 2, x + w, y + topCurveHeight);
          ctx.bezierCurveTo(x + w, y, x + w / 2, y, x + w / 2, y + h * 0.2);
          ctx.closePath();
        }
      },
      'check': {
        name: 'Check', icon: '‚úîÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x, y + h * 0.5); ctx.lineTo(x + w * 0.4, y + h); ctx.lineTo(x + w, y);
        }
      },
      'cross': {
        name: 'Cross', icon: '‚ùå', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x, y); ctx.lineTo(x + w, y + h);
          ctx.moveTo(x + w, y); ctx.lineTo(x, y + h);
        }
      },
      'thought': {
        name: 'Thought', icon: 'üí≠', path: (ctx, x, y, w, h) => {
          ctx.ellipse(x + w * 0.5, y + h * 0.4, w * 0.4, h * 0.3, 0, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.3, y + h * 0.7); ctx.arc(x + w * 0.2, y + h * 0.8, w * 0.05, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.15, y + h * 0.9); ctx.arc(x + w * 0.1, y + h * 0.95, w * 0.03, 0, 2 * Math.PI);
        }
      },
      'cube': {
        name: 'Cube', icon: 'üßä', path: (ctx, x, y, w, h) => {
          const d = w * 0.25;
          ctx.rect(x, y + d, w - d, h - d);
          ctx.moveTo(x, y + d); ctx.lineTo(x + d, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w - d, y + d);
          ctx.moveTo(x + w, y); ctx.lineTo(x + w, y + h - d); ctx.lineTo(x + w - d, y + h);
        }
      },
      'cylinder': {
        name: 'Cylinder', icon: 'üõ¢Ô∏è', path: (ctx, x, y, w, h) => {
          const eh = h * 0.15;
          ctx.ellipse(x + w / 2, y + eh, w / 2, eh, 0, 0, 2 * Math.PI);
          ctx.moveTo(x, y + eh); ctx.lineTo(x, y + h - eh);
          ctx.ellipse(x + w / 2, y + h - eh, w / 2, eh, 0, 0, Math.PI); // Bottom half
          ctx.lineTo(x + w, y + eh);
        }
      },
      'smiley': {
        name: 'Smile', icon: 'üôÇ', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI); // Face
          ctx.moveTo(x + w * 0.3, y + h * 0.4); ctx.arc(x + w * 0.3, y + h * 0.4, w * 0.05, 0, 2 * Math.PI); // Eye L
          ctx.moveTo(x + w * 0.7, y + h * 0.4); ctx.arc(x + w * 0.7, y + h * 0.4, w * 0.05, 0, 2 * Math.PI); // Eye R
          ctx.moveTo(x + w * 0.2, y + h * 0.6); ctx.bezierCurveTo(x + w * 0.2, y + h * 0.9, x + w * 0.8, y + h * 0.9, x + w * 0.8, y + h * 0.6);
        }
      },
      'parallelogram': {
        name: 'Parallelogram', icon: '‚ñ∞', path: (ctx, x, y, w, h) => {
          const skew = w * 0.2;
          ctx.moveTo(x + skew, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w - skew, y + h); ctx.lineTo(x, y + h); ctx.closePath();
        }
      },
      'trapezoid': {
        name: 'Trapezoid', icon: '‚è¢', path: (ctx, x, y, w, h) => {
          const inset = w * 0.2;
          ctx.moveTo(x + inset, y); ctx.lineTo(x + w - inset, y); ctx.lineTo(x + w, y + h); ctx.lineTo(x, y + h); ctx.closePath();
        }
      },
      'hexagon': {
        name: 'Hexagon', icon: '‚¨°', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = Math.min(w, h) / 2;
          for (let i = 0; i < 6; i++) {
            ctx.lineTo(cx + r * Math.cos(i * 2 * Math.PI / 6), cy + r * Math.sin(i * 2 * Math.PI / 6));
          }
          ctx.closePath();
        }
      },
      'pentagon': {
        name: 'Pentagon', icon: '‚¨†', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = Math.min(w, h) / 2;
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(cx + r * Math.cos(i * 2 * Math.PI / 5 - Math.PI / 2), cy + r * Math.sin(i * 2 * Math.PI / 5 - Math.PI / 2));
          }
          ctx.closePath();
        }
      },
      'document': {
        name: 'Document', icon: 'üìÑ', path: (ctx, x, y, w, h) => {
          const fold = w * 0.3;
          ctx.moveTo(x, y); ctx.lineTo(x + w - fold, y); ctx.lineTo(x + w, y + fold); ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h); ctx.closePath();
          ctx.moveTo(x + w - fold, y); ctx.lineTo(x + w - fold, y + fold); ctx.lineTo(x + w, y + fold);
        }
      },
      'database': {
        name: 'Database', icon: 'üóÑÔ∏è', path: (ctx, x, y, w, h) => {
          const eh = h * 0.15;
          ctx.ellipse(x + w / 2, y + eh, w / 2, eh, 0, 0, 2 * Math.PI);
          ctx.moveTo(x, y + eh); ctx.lineTo(x, y + h - eh);
          ctx.ellipse(x + w / 2, y + h - eh, w / 2, eh, 0, 0, Math.PI);
          ctx.lineTo(x + w, y + eh);
          ctx.moveTo(x, y + h * 0.5); ctx.ellipse(x + w / 2, y + h * 0.5, w / 2, eh, 0, 0, Math.PI);
        }
      },
      'sun': {
        name: 'Sun', icon: '‚òÄÔ∏è', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = w * 0.25;
          ctx.arc(cx, cy, r, 0, 2 * Math.PI);
          for (let i = 0; i < 8; i++) {
            const angle = i * Math.PI / 4;
            ctx.moveTo(cx + Math.cos(angle) * r * 1.2, cy + Math.sin(angle) * r * 1.2);
            ctx.lineTo(cx + Math.cos(angle) * r * 1.8, cy + Math.sin(angle) * r * 1.8);
          }
        }
      },
      'moon': {
        name: 'Moon', icon: 'üåô', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w / 2, y + h / 2, w * 0.4, 0, 2 * Math.PI); // Base circle
          // Simplified clip? Canvas path clip is complex in one stroke.
          // Just draw a crescent using bezier
          ctx.moveTo(x + w * 0.5, y + h * 0.1);
          ctx.bezierCurveTo(x + w, y + h * 0.5, x + w * 0.5, y + h * 0.9, x + w * 0.5, y + h * 0.9);
          ctx.bezierCurveTo(x + w * 0.8, y + h * 0.5, x + w * 0.5, y + h * 0.1, x + w * 0.5, y + h * 0.1);
        }
      },
      'lightning': {
        name: 'Lightning', icon: '‚ö°', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w * 0.6, y); ctx.lineTo(x + w * 0.3, y + h * 0.6); ctx.lineTo(x + w * 0.5, y + h * 0.6);
          ctx.lineTo(x + w * 0.4, y + h); ctx.lineTo(x + w * 0.7, y + h * 0.4); ctx.lineTo(x + w * 0.5, y + h * 0.4);
          ctx.closePath();
        }
      },
      'lock': {
        name: 'Lock', icon: 'üîí', path: (ctx, x, y, w, h) => {
          ctx.rect(x + w * 0.2, y + h * 0.4, w * 0.6, h * 0.6);
          ctx.moveTo(x + w * 0.3, y + h * 0.4); ctx.arc(x + w * 0.5, y + h * 0.4, w * 0.2, Math.PI, 0);
        }
      },
      'key': {
        name: 'Key', icon: 'üîë', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w * 0.2, y + h * 0.5, w * 0.2, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.4, y + h * 0.5); ctx.lineTo(x + w * 0.9, y + h * 0.5);
          ctx.lineTo(x + w * 0.9, y + h * 0.7);
          ctx.moveTo(x + w * 0.7, y + h * 0.5); ctx.lineTo(x + w * 0.7, y + h * 0.7);
        }
      },
      'envelope': {
        name: 'Envelope', icon: '‚úâÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.rect(x, y + h * 0.2, w, h * 0.8);
          ctx.moveTo(x, y + h * 0.2); ctx.lineTo(x + w / 2, y + h * 0.6); ctx.lineTo(x + w, y + h * 0.2);
        }
      },
    };

    let wbState = {
      id: null,
      name: "Untitled",
      tool: 'pen',
      shapeType: null, // if tool is shape
      color: '#000000',
      size: 4,
      isDrawing: false,
      startX: 0, startY: 0,
      history: [], // Elements
      redoStack: [],
      canvas: null,
      ctx: null,
      container: null
    };

    // --- Dashboard ---
    function showWhiteboardDashboard() {
      document.getElementById('sidebar').classList.add('hidden');
      if (window.innerWidth <= 768) {
        document.querySelector('.sidebar').style.display = 'none';
        document.querySelector('.main-chat').style.display = 'none';
      }
      chatArea.classList.add('hidden');
      document.getElementById('welcomeScreen').classList.add('hidden');
      document.getElementById('whiteboardDashboard').classList.remove('hidden');
      loadWhiteboards();
    }

    async function loadWhiteboards() {
      const grid = document.getElementById('wbGrid');
      grid.innerHTML = '<p>Loading...</p>';
      try {
        const boards = await api('/api/whiteboards');
        grid.innerHTML = '';
        if (boards.length === 0) {
          grid.innerHTML = '<p>No whiteboards yet. Create one!</p>';
          return;
        }
        boards.forEach(b => {
          const card = document.createElement('div');
          card.className = 'wb-card';
          card.innerHTML = `
                    <div class="wb-thumbnail">${b.thumbnail ? '<img src="' + b.thumbnail + '" style="width:100%;height:100%;object-fit:cover;">' : 'üé®'}</div>
                    <div class="wb-title">${b.name}</div>
                    <div class="wb-date">${new Date(b.updated_at).toLocaleDateString()}</div>
                    <button onclick="deleteWhiteboard(event, ${b.id})" style="position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:white; border-radius:50%; width:24px; height:24px; display:flex; 
                    align-items:center; justify-content:center; border:none;">‚úï</button>
                `;
          card.onclick = (e) => {
            if (e.target.tagName === 'BUTTON') return;
            openWhiteboardStandalone(b.id);
          };
          grid.appendChild(card);
        });
      } catch (e) {
        grid.innerHTML = '<p style="color:red">Failed to load whiteboards</p>';
      }
    }

    async function createNewWhiteboard() {
      try {
        const res = await api('/api/whiteboards', {
          method: 'POST',
          body: JSON.stringify({ name: "Untitled Whiteboard" })
        });
        openWhiteboardStandalone(res.id);
      } catch (e) {
        alert("Error creating whiteboard: " + e.message);
      }
    }

    async function deleteWhiteboard(e, id) {
      e.stopPropagation();
      if (!confirm("Delete this whiteboard?")) return;
      try {
        await api(`/api/whiteboards/${id}`, { method: 'DELETE' });
        loadWhiteboards();
      } catch (e) {
        alert("Failed to delete");
      }
    }

    // --- UI & Interaction ---
    async function openWhiteboardStandalone(id) {
      try {
        const data = await api(`/api/whiteboards/${id}`);
        wbState.id = data.id;
        wbState.name = data.name;
        wbState.history = data.data ? JSON.parse(data.data) : [];
        wbState.redoStack = [];

        document.getElementById('wbTitle').value = wbState.name;
        document.getElementById('whiteboardUI').classList.remove('hidden');

        initWhiteboardCanvas();
        redrawCanvas();
        renderShapePicker();
      } catch (e) {
        alert("Failed to open whiteboard: " + e.message);
      }
    }

    function initWhiteboardCanvas() {
      wbState.container = document.getElementById('wbCanvasContainer');
      wbState.canvas = document.getElementById('wbCanvasNew');
      wbState.ctx = wbState.canvas.getContext('2d');
      wbState.canvas.width = 3000;
      wbState.canvas.height = 3000;

      const cvs = wbState.canvas;
      cvs.addEventListener('mousedown', wbStart);
      cvs.addEventListener('mousemove', wbMove);
      cvs.addEventListener('mouseup', wbEnd);
      cvs.addEventListener('mouseout', wbEnd);

      cvs.addEventListener('touchstart', (e) => {
        if (wbState.tool === 'pen' || wbState.tool === 'eraser') e.preventDefault();
        wbStart(e.touches[0]);
      });
      cvs.addEventListener('touchmove', (e) => {
        if (wbState.tool === 'pen' || wbState.tool === 'eraser') e.preventDefault();
        wbMove(e.touches[0]);
      });
      cvs.addEventListener('touchend', wbEnd);
    }

    function closeWhiteboardUI() {
      document.getElementById('whiteboardUI').classList.add('hidden');
      loadWhiteboards();
    }

    function wbGetPos(e) {
      const rect = wbState.canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (wbState.canvas.width / rect.width),
        y: (e.clientY - rect.top) * (wbState.canvas.height / rect.height)
      };
    }

    function wbStart(e) {
      wbState.isDrawing = true;
      const pos = wbGetPos(e);
      wbState.startX = pos.x;
      wbState.startY = pos.y;

      if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.currentPath = {
          type: 'path',
          points: [{ x: pos.x, y: pos.y }],
          color: wbState.tool === 'eraser' ? '#ffffff' : wbState.color,
          size: wbState.tool === 'eraser' ? wbState.size * 5 : wbState.size,
          isEraser: wbState.tool === 'eraser'
        };
      } else if (wbState.tool === 'text') {
        const text = prompt("Enter text:");
        if (text) {
          wbState.history.push({
            type: 'text', x: pos.x, y: pos.y, text: text, color: wbState.color, size: wbState.size * 5
          });
          redrawCanvas();
          saveWhiteboard(true);
        }
        wbState.isDrawing = false;
      }
    }

    function wbMove(e) {
      if (!wbState.isDrawing) return;
      const pos = wbGetPos(e);

      if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.currentPath.points.push({ x: pos.x, y: pos.y });

        const ctx = wbState.ctx;
        ctx.beginPath();
        const pts = wbState.currentPath.points;
        if (pts.length > 1) {
          ctx.moveTo(pts[pts.length - 2].x, pts[pts.length - 2].y);
          ctx.lineTo(pos.x, pos.y);
          ctx.strokeStyle = wbState.currentPath.color;
          ctx.lineWidth = wbState.currentPath.size;
          ctx.lineCap = 'round';
          ctx.stroke();
        }
      } else if (wbState.tool === 'shape') {
        redrawCanvas();
        const ctx = wbState.ctx;
        ctx.beginPath();
        ctx.strokeStyle = wbState.color;
        ctx.lineWidth = wbState.size;

        const w = pos.x - wbState.startX;
        const h = pos.y - wbState.startY;

        const shapeDef = SHAPES[wbState.shapeType];
        if (shapeDef) {
          shapeDef.path(ctx, wbState.startX, wbState.startY, w, h);
          ctx.stroke();
        }
      }
    }

    function wbEnd(e) {
      if (!wbState.isDrawing) return;
      wbState.isDrawing = false;

      if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.history.push(wbState.currentPath);
      } else if (wbState.tool === 'shape') {
        let pos;
        try { pos = wbGetPos(e); } catch (ex) { return; }

        const w = pos.x - wbState.startX;
        const h = pos.y - wbState.startY;

        if (Math.abs(w) > 5 || Math.abs(h) > 5) {
          wbState.history.push({
            type: 'shape',
            shape: wbState.shapeType,
            x: wbState.startX,
            y: wbState.startY,
            w: w, h: h,
            color: wbState.color,
            size: wbState.size
          });
        }
        redrawCanvas();
      }

      saveWhiteboard(true);
    }

    function redrawCanvas() {
      const ctx = wbState.ctx;
      ctx.clearRect(0, 0, wbState.canvas.width, wbState.canvas.height);

      wbState.history.forEach(action => {
        ctx.beginPath();
        if (action.type === 'path') {
          ctx.strokeStyle = action.color;
          ctx.lineWidth = action.size;
          ctx.lineCap = 'round';
          if (action.points.length > 0) {
            ctx.moveTo(action.points[0].x, action.points[0].y);
            for (let i = 1; i < action.points.length; i++) {
              ctx.lineTo(action.points[i].x, action.points[i].y);
            }
          }
          ctx.stroke();
        } else if (action.type === 'shape') {
          ctx.strokeStyle = action.color;
          ctx.lineWidth = action.size;
          const def = SHAPES[action.shape];
          if (def) def.path(ctx, action.x, action.y, action.w, action.h);
          ctx.stroke();
        } else if (action.type === 'text') {
          ctx.fillStyle = action.color;
          ctx.font = `${action.size * 3}px sans-serif`;
          ctx.fillText(action.text, action.x, action.y);
        }
      });
    }

    // --- Toolbar ---
    function setTool(tool) {
      wbState.tool = tool;
      document.querySelectorAll('.wb-tool-btn').forEach(b => b.classList.remove('active'));
      document.getElementById(`tool-${tool === 'shape' ? 'shapes' : tool}`).classList.add('active');

      if (tool !== 'shape') document.getElementById('wbShapePicker').style.display = 'none';
    }

    function setColor(c) { wbState.color = c; }
    function setSize(s) { wbState.size = s; }

    function toggleShapePicker() {
      const p = document.getElementById('wbShapePicker');
      p.style.display = p.style.display === 'grid' ? 'none' : 'grid';
    }

    function setShape(shape) {
      wbState.tool = 'shape';
      wbState.shapeType = shape;
      document.querySelectorAll('.wb-tool-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('tool-shapes').classList.add('active');
      toggleShapePicker();
    }

    function renderShapePicker() {
      const picker = document.getElementById('wbShapePicker');
      picker.innerHTML = '';
      Object.keys(SHAPES).forEach(k => {
        const div = document.createElement('div');
        div.className = 'wb-shape-item';
        div.innerHTML = `<span style="font-size:1.5rem;">${SHAPES[k].icon}</span>`;
        div.title = SHAPES[k].name;
        div.onclick = () => setShape(k);
        picker.appendChild(div);
      });
    }

    // --- Persistence ---
    async function saveWhiteboardName() {
      wbState.name = document.getElementById('wbTitle').value;
      saveWhiteboard();
    }

    async function saveWhiteboard(silent = false) {
      const status = document.getElementById('wbSaveStatus');
      if (!silent) status.textContent = 'Saving...';

      try {
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = 300; thumbCanvas.height = 200;
        const tCtx = thumbCanvas.getContext('2d');
        tCtx.fillStyle = 'white';
        tCtx.fillRect(0, 0, 300, 200);
        tCtx.drawImage(wbState.canvas, 0, 0, 300, 200);
        const thumb = thumbCanvas.toDataURL('image/jpeg', 0.5);

        await api(`/api/whiteboards/${wbState.id}/save`, {
          method: 'POST',
          body: JSON.stringify({
            name: wbState.name,
            data: JSON.stringify(wbState.history),
            thumbnail: thumb
          })
        });
        status.textContent = 'Saved';
        setTimeout(() => status.textContent = 'Saved', 2000);
      } catch (e) {
        status.textContent = 'Error Saving';
        console.error(e);
      }
    }
  </script>
</body>

</html>