<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

    :root {
      /* DEFAULT: Dark Mode */
      --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);

      --glass-panel-bg: rgba(30, 41, 59, 0.6);
      --glass-header-bg: rgba(15, 23, 42, 0.8);
      --glass-sidebar-bg: rgba(15, 23, 42, 0.4);
      --glass-input-bg: rgba(0, 0, 0, 0.2);

      --glass-border: 1px solid rgba(255, 255, 255, 0.1);
      --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);

      --primary-gradient: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);

      --text-main: #f8fafc;
      --text-muted: #94a3b8;
      --text-inverse: #ffffff;

      --border-elegant: 1px solid rgba(255, 255, 255, 0.1);

      /* Refined Message Style (Glassy) */
      --msg-bg-other: rgba(0, 0, 0, 0.3);
      --msg-bg-user: var(--primary-gradient);

      --item-hover-bg: rgba(255, 255, 255, 0.05);

      --radius-md: 16px;
      --radius-lg: 24px;
      --radius-pill: 9999px;
    }

    body.light-mode {
      /* Light Mode Overrides */
      --bg-gradient: linear-gradient(120deg, #f0f4f8 0%, #d9e2ec 100%);

      --glass-panel-bg: rgba(255, 255, 255, 0.85);
      /* Increased opacity for light mode visibility */
      --glass-header-bg: rgba(255, 255, 255, 0.85);
      --glass-sidebar-bg: rgba(255, 255, 255, 0.5);
      --glass-input-bg: rgba(255, 255, 255, 0.8);

      --glass-border: 1px solid rgba(0, 0, 0, 0.05);
      --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.08);

      --text-main: #1e293b;
      --text-muted: #64748b;
      --text-inverse: #ffffff;

      --border-elegant: 1px solid rgba(0, 0, 0, 0.08);

      --msg-bg-other: rgba(255, 255, 255, 0.9);
      --item-hover-bg: rgba(0, 0, 0, 0.05);
    }

    /* NEW: Notepad Styles via CSS for light/dark support */
    #notepadUI {
      background: var(--glass-panel-bg);
      backdrop-filter: blur(20px);
    }

    .notepad-title-input {
      width: 100%;
      font-size: 1.5rem;
      background: transparent;
      border: none;
      color: var(--text-main);
      outline: none;
    }

    .notepad-textarea {
      width: 100%;
      height: 100%;
      background: var(--glass-input-bg);
      border: var(--border-elegant);
      color: var(--text-main);
      font-size: 1.2rem;
      padding: 20px;
      border-radius: 10px;
      resize: none;
      outline: none;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }

    body {
      background: var(--bg-gradient);
      color: var(--text-main);
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      transition: background 0.5s ease;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .hidden {
      display: none !important;
    }

    /* Main Container with Glassmorphism */
    .container {
      max-width: 1400px;
      width: 95%;
      height: 92vh;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      border: var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--glass-shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Sidebar Tabs layout */
    .sidebar-tabs {
      display: flex;
      padding: 10px;
      gap: 5px;
    }

    .sidebar-tab {
      flex: 1;
      text-align: center;
      padding: 8px;
      border-radius: var(--radius-pill);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-muted);
      transition: all 0.2s;
    }

    .sidebar-tab.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-main);
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      display: none;
      /* Toggled */
    }

    .sidebar-content.active {
      display: block;
    }

    /* Status UI */
    .status-item {
      display: flex;
      align-items: center;
      padding: 12px;
      cursor: pointer;
      transition: background 0.2s;
      border-radius: var(--radius-md);
    }

    .status-item:hover {
      background: var(--item-hover-bg);
    }

    .status-ring {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      padding: 2px;
      background: var(--text-muted);
      /* Read/Default */
      margin-right: 12px;
    }

    .status-ring.unread {
      background: var(--primary-gradient);
    }

    .status-ring img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--glass-sidebar-bg);
      /* Gap effect */
    }

    /* Status Viewer Overlay */
    #statusViewer {
      position: fixed;
      inset: 0;
      background: black;
      z-index: 5000;
      display: none;
      flex-direction: column;
    }

    #statusProgressContainer {
      display: flex;
      gap: 4px;
      padding: 10px;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 5001;
    }

    .status-progress-bar {
      flex: 1;
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      overflow: hidden;
    }

    .status-progress-fill {
      height: 100%;
      background: white;
      width: 0%;
    }

    #statusContentArea {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #statusContentArea img,
    #statusContentArea video {
      max-width: 100%;
      max-height: 100%;
    }

    .status-text-view {
      font-size: 2rem;
      color: white;
      text-align: center;
      padding: 20px;
      background: var(--primary-gradient);
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Common Buttons */
    button {
      cursor: pointer;
      border: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: 'Inter', sans-serif;
    }

    button:active {
      transform: scale(0.96);
    }

    .secondary-btn {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
      border: var(--border-elegant);
      padding: 10px 20px;
      /* Ensure good sizing */
      border-radius: var(--radius-pill);
    }

    .secondary-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: var(--text-main);
    }

    /* Inputs */
    input,
    select {
      padding: 14px 20px;
      border: var(--border-elegant);
      background: var(--glass-input-bg);
      border-radius: var(--radius-pill);
      color: var(--text-main);
      transition: all 0.2s ease;
      outline: none;
      font-size: 0.95rem;
    }

    input::placeholder {
      color: var(--text-muted);
      opacity: 0.7;
    }

    input:focus,
    select:focus {
      background: rgba(0, 0, 0, 0.3);
      border-color: #8b5cf6;
      box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
    }

    /* Auth Screens */
    .auth-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
      padding: 2rem;
    }

    .auth-screen h2 {
      margin-bottom: 2rem;
      font-size: 3rem;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 800;
      letter-spacing: -1px;
    }

    .auth-screen h3 {
      color: var(--text-main);
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .auth-screen .auth-form {
      width: 100%;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      background: var(--glass-panel-bg);
      padding: 2rem;
      border-radius: var(--radius-lg);
      border: var(--glass-border);
    }

    .auth-screen input {
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      /* keep simplified for auth, or use var --glass-input-bg */
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .auth-screen button {
      background: var(--primary-gradient);
      color: white;
      padding: 16px;
      border-radius: var(--radius-pill);
      font-weight: 600;
      font-size: 1.1rem;
      box-shadow: 0 10px 20px -5px rgba(99, 102, 241, 0.4);
    }

    .auth-screen button:hover {
      box-shadow: 0 15px 25px -5px rgba(99, 102, 241, 0.5);
      transform: translateY(-2px);
    }

    .auth-screen p {
      margin-top: 1rem;
      color: var(--text-muted);
      text-align: center;
    }

    .auth-screen a {
      color: #a855f7;
      text-decoration: none;
      font-weight: 500;
    }

    /* App Header */
    .app-header {
      background: var(--glass-header-bg);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: var(--border-elegant);
      border-bottom: var(--border-elegant);
      z-index: 20;
    }

    .logo-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-container img {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
    }

    .app-header span {
      font-size: 1.8rem;
      font-weight: 800;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.5px;
    }

    .app-header button {
      margin-left: 10px;
      background: var(--item-hover-bg);
      color: var(--text-main);
      padding: 10px 20px;
      border-radius: var(--radius-pill);
      font-weight: 500;
      font-size: 0.9rem;
      border: var(--border-elegant);
    }

    .app-header button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .app-header button:last-child {
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
      border-color: rgba(239, 68, 68, 0.2);
    }

    .app-header button:last-child:hover {
      background: rgba(239, 68, 68, 0.2);
    }

    /* Layout */
    .layout-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 340px;
      background: var(--glass-sidebar-bg);
      border-right: var(--border-elegant);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar button {
      background: var(--primary-gradient);
      color: white;
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-pill);
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }

    .sidebar h4 {
      padding: 1.5rem 1.5rem 0.5rem;
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

    .chat-list {
      list-style: none;
      padding: 0 1rem 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .chat-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 8px;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .chat-item:hover {
      background: var(--item-hover-bg);
      border: var(--glass-border);
      transform: translateX(4px);
    }

    .chat-item .dp {
      width: 50px;
      height: 50px;
      border-radius: 18px;
      /* Slightly squircle */
      object-fit: cover;
      margin-right: 14px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    .chat-item span {
      font-weight: 600;
      color: var(--text-main);
      font-size: 1rem;
    }

    /* Main Chat Area */
    .main-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: transparent;
      position: relative;
      min-width: 0;
    }

    /* Chat Header */
    .chat-header {
      padding: 0 30px;
      height: 80px;
      border-bottom: var(--border-elegant);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--glass-header-bg);
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 10;
    }

    .chat-header img.dp {
      width: 46px;
      height: 46px;
      border-radius: 16px;
      margin-right: 15px;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .chat-header span {
      color: var(--text-main);
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat-actions button {
      background: var(--item-hover-bg);
      padding: 10px;
      border-radius: 14px;
      width: 44px;
      height: 44px;
      color: var(--text-muted);
      font-size: 1.2rem;
      border: var(--border-elegant);
      margin-left: 8px;
    }

    .chat-actions button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-main);
    }

    /* Messages Area */
    .messages {
      flex: 1;
      padding: 30px;
      overflow-y: auto;
      position: relative;
      z-index: 5;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 20px;
      /* Reduce spread by adding horizontal padding */
      max-width: 1400px;
      /* Constrain reading width */
      margin: 0 auto;
      /* Center the stream */
      width: 100%;
    }

    #chat-background {
      position: absolute;
      inset: 0;
      z-index: 0;
      overflow: hidden;
      pointer-events: none;
    }

    /* STATIC THEMES */
    /* Theme definitions will apply to #chat-background */

    /* STATIC THEMES - IMAGES */
    /* Theme definitions will apply to #chat-background */

    .theme-default {
      background: transparent;
    }

    .theme-bg1 {
      background-image: url('static/bg1.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg2 {
      background-image: url('static/bg2.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg3 {
      background-image: url('static/bg3.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg4 {
      background-image: url('static/bg4.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg5 {
      background-image: url('static/bg5.png');
      background-size: cover;
      background-position: center;
    }

    .theme-bg6 {
      background-image: url('static/bg6.png');
      background-size: cover;
      background-position: center;
    }

    /* Theme Selector UI in Settings */
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }

    .theme-option {
      height: 50px;
      border-radius: 12px;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s, border-color 0.2s;
    }

    .theme-option:hover {
      transform: scale(1.05);
      border-color: white;
    }

    .theme-option.active {
      border-color: #a855f7;
      box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.4);
    }

    .message {
      max-width: 65%;
      padding: 14px 20px;
      margin: 8px 0;
      border-radius: 20px;
      /* More rounded */
      position: relative;
      font-size: 1rem;
      line-height: 1.6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: messagePop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes messagePop {
      0% {
        transform: scale(0.9) translateY(10px);
        opacity: 0;
      }

      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .message.user {
      align-self: flex-end;
      background: var(--msg-bg-user);
      color: white;
      border-bottom-right-radius: 4px;
      /* Distinctive shape */
      box-shadow: 0 8px 20px -5px rgba(124, 58, 237, 0.5);
      /* Glow */
    }

    .message.other {
      align-self: flex-start;
      background: var(--msg-bg-other);
      /* Dark glass message */
      color: var(--text-main);
      border-bottom-left-radius: 4px;
      border-bottom-left-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      /* Add glass blur */
      /* keep subtle */
    }

    .message.pending {
      opacity: 0.7;
    }

    .message img {
      max-width: 100%;
      max-height: 250px;
      /* Keep images compact */
      width: auto;
      object-fit: contain;
      border-radius: 12px;
      margin-top: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      /* Indicate clickable */
    }

    .sender-name {
      font-size: 0.8rem;
      font-weight: 700;
      color: #a855f7;
      margin-bottom: 4px;
    }

    /* Reactions updated look */
    .reactions {
      display: flex;
      flex-wrap: wrap;
      margin-top: 6px;
      gap: 6px;
    }

    .reaction {
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-muted);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s;
    }

    .reaction:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.1);
    }

    .message.user .reaction {
      background: rgba(0, 0, 0, 0.2);
      color: rgba(255, 255, 255, 0.9);
      border: none;
    }

    .seen-container {
      display: flex;
      justify-content: flex-end;
      margin-top: 2px;
    }

    .seen-status {
      padding: 2px 6px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: background 0.2s;
    }

    .seen-status:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Fixed Search Result Item */
    .search-result-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
      color: var(--text-main);
    }

    .search-result-item:hover {
      background: var(--item-hover-bg);
    }

    .search-result-item img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
    }


    /* Input Area */
    .input-area {
      padding: 24px;
      background: var(--glass-header-bg);
      border-top: var(--border-elegant);
      display: flex;
      align-items: center;
      gap: 16px;
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 10;
    }

    .input-area input {
      flex: 1;
      padding: 16px 24px;
      border-radius: var(--radius-pill);
      background: var(--glass-input-bg);
      border: var(--border-elegant);
      font-size: 1rem;
      color: var(--text-main);
    }

    .input-area input::placeholder {
      color: var(--text-muted);
    }

    .input-area button {
      background: var(--primary-gradient);
      color: white;
      width: 54px;
      height: 54px;
      border-radius: 50%;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
    }

    .input-area button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(124, 58, 237, 0.5);
    }

    /* Modals & Popups */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.6);
      /* Darker backdrop */
      backdrop-filter: blur(8px);
    }

    .modal-content {
      /* Content styling */
      background: var(--glass-panel-bg);
      border: var(--glass-border);
      border-radius: 24px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      color: var(--text-main);
      padding: 24px;
      width: 90%;
      max-width: 400px;
    }

    .modal-content h3 {
      color: var(--text-main);
      font-size: 1.8rem;
    }

    #emojiPicker {
      background: rgba(30, 41, 59, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      border-radius: 20px;
      position: fixed;
      /* Changed from default (likely absolute) to fixed */
      z-index: 10000;
      /* High z-index to stay on top */
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      padding: 15px;
      width: 250px;
    }

    .emoji {
      font-size: 1.5rem;
      cursor: pointer;
      text-align: center;
      transition: transform 0.2s;
    }

    .emoji:hover {
      transform: scale(1.2);
    }

    .member-item {
      color: var(--text-main);
      padding: 8px;
      border-radius: 8px;
    }

    .member-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Search Results Visibility Fix */
    #searchResults {
      background: var(--glass-header-bg);
      border: var(--glass-border);
      border-radius: 12px;
      margin-top: 10px;
      overflow: hidden;
    }

    #searchResults div {
      padding: 10px;
      color: var(--text-main);
      /* Ensure visible in light mode */
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      cursor: pointer;
    }

    #searchResults div:hover {
      background: var(--item-hover-bg);
    }

    /* Adjust specific text colors which might be hardcoded in HTML - Handled by class selection */

    /* Mobile Responsiveness */
    #mobileBackBtn {
      display: none;
      margin-right: 10px;
      font-size: 1.2rem;
      background: transparent;
      color: var(--text-main);
      padding: 5px;
      border: none;
    }

    @media (max-width: 768px) {
      .container {
        width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
      }

      .layout-wrapper {
        position: relative;
      }

      /* By default on mobile, show sidebar, hide chat */
      .sidebar {
        width: 100%;
        border-right: none;
        display: flex;
      }

      .main-chat {
        display: none;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: var(--glass-panel-bg);
        /* Ensure opaque background */
        z-index: 50;
      }

      /* Class to toggle view */
      .show-chat .sidebar {
        display: none;
      }

      .show-chat .main-chat {
        display: flex;
      }

      #welcomeScreen {
        display: none !important;
      }

      /* Don't show welcome on mobile, just list */

      #mobileBackBtn {
        display: block;
      }

      .app-header {
        display: none;
      }

      /* Optional: hide main app header to save space? or keep it? Let's keep it but maybe smaller padding */
      .app-header {
        padding: 0.5rem 1rem;
      }

      .app-header span {
        font-size: 1.5rem;
        font-weight: 700;
        margin-left: 10px;
      }

      .logo-container {
        display: flex;
        align-items: center;
      }

      .logo-container img {
        width: 36px;
        height: 36px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
      }

      /* Adjust chat header */
      .chat-header {
        padding: 0 10px;
      }
    }

    /* New Search Results */
    #searchResults {
      position: absolute;
      width: 100%;
      background: #1e293b;
      /* Solid background for visibility */
      border: var(--glass-border);
      border-radius: 12px;
      margin-top: 5px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 2000;
      /* Ensure on top of everything */
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      display: none;
    }

    .search-result-item {
      padding: 10px;
      display: flex;
      align-items: center;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .search-result-item:hover {
      background: var(--item-hover-bg);
    }

    .search-result-item img {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 10px;
    }

    /* Stylish Request Cards */
    .request-card {
      background: rgba(255, 255, 255, 0.05);
      border: var(--border-elegant);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: transform 0.2s;
    }

    .request-card:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    /* DP Overlay */
    .dp-container {
      position: relative;
      width: 80px;
      height: 80px;
      margin-right: 16px;
    }

    .dp-container img {
      width: 100%;
      height: 100%;
      border-radius: 24px;
      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .dp-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .dp-container:hover .dp-overlay {
      opacity: 1;
    }

    .dp-overlay span {
      font-size: 1.5rem;
      color: white;
    }

    /* Call UI */
    #callOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .call-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.2);
      margin-bottom: 20px;
      box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
      }

      70% {
        box-shadow: 0 0 0 20px rgba(168, 85, 247, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(168, 85, 247, 0);
      }
    }

    .call-actions button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      font-size: 1.5rem;
      margin: 0 15px;
      border: none;
      display: flex;
      /* flex center */
      align-items: center;
      justify-content: center;
      transition: transform 0.2s;
    }

    .call-actions button:hover {
      transform: scale(1.1);
    }

    .btn-end {
      background: #ef4444;
      color: white;
    }

    .btn-mute {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .btn-accept {
      background: #22c55e;
      color: white;
    }

    /* Whiteboard Dashboard */
    .wb-dashboard {
      flex: 1;
      padding: 30px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .wb-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
    }

    .wb-card {
      background: rgba(255, 255, 255, 0.05);
      border: var(--border-elegant);
      border-radius: 16px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: all 0.2s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .wb-card:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
    }

    .wb-thumbnail {
      width: 100%;
      height: 120px;
      background: white;
      border-radius: 8px;
      object-fit: cover;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ccc;
      font-size: 2rem;
    }

    .wb-title {
      font-weight: 600;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .wb-date {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    /* Whiteboard UI (Standalone) */
    .wb-ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-gradient);
      z-index: 5000;
      display: flex;
      flex-direction: column;
    }

    .wb-header {
      height: 60px;
      background: var(--glass-header-bg);
      backdrop-filter: blur(10px);
      border-bottom: var(--border-elegant);
      display: flex;
      align-items: center;
      padding: 0 20px;
      justify-content: space-between;
      color: var(--text-main);
    }

    .wb-header input {
      background: transparent;
      border: 1px solid transparent;
      color: var(--text-main);
      font-size: 1.2rem;
      font-weight: 600;
      width: 300px;
    }

    .wb-header input:focus {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.2);
    }

    .wb-toolbar {
      width: 100%;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(10px);
      border-bottom: var(--border-elegant);
      padding: 10px;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 20px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      z-index: 10;
      /* position: relative is default in flex flow */
    }

    .wb-canvas-container {
      flex: 1;
      /* Take remaining height */
      position: relative;
      overflow: hidden;
      cursor: crosshair;
      background: white;
      /* Ensure bg is white/dark-ready */
    }

    .wb-tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: transparent;
      color: var(--text-muted);
      border: 1px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }

    .wb-tool-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-main);
    }

    .wb-tool-btn.active {
      background: var(--primary-gradient);
      color: white;
      box-shadow: 0 4px 10px rgba(124, 58, 237, 0.4);
    }

    .wb-canvas-container {
      flex: 1;
      overflow: auto;
      background: #f1f5f9;
      /* Graph paper generic bg, or white */
      position: relative;
      cursor: crosshair;
    }

    body.light-mode .wb-canvas-container {
      background: #ffffff;
    }

    /* Shape Picker Popover */
    .wb-shape-picker {
      position: absolute;
      left: 60px;
      /* Right of toolbar */
      top: 0;
      width: 280px;
      background: var(--glass-panel-bg);
      backdrop-filter: blur(20px);
      border: var(--border-elegant);
      border-radius: 12px;
      padding: 15px;
      display: none;
      /* Toggled */
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    .wb-shape-item {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .wb-shape-item svg {
      width: 24px;
      height: 24px;
      stroke: var(--text-main);
      fill: none;
      stroke-width: 2;
    }

    .wb-shape-item:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    /* Status Like */
    .status-like-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 5003;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    #shareItemModal {
      z-index: 6000;
    }


    .status-like-btn {
      font-size: 2rem;
      cursor: pointer;
      transition: transform 0.2s;
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
    }

    .status-like-btn:active {
      transform: scale(0.8);
    }

    .status-like-btn.liked {
      color: #ef4444;
      animation: likePop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes likePop {
      0% {
        transform: scale(0.5);
      }

      50% {
        transform: scale(1.3);
      }

      100% {
        transform: scale(1);
      }
    }

    .status-like-count {
      color: white;
      font-size: 0.9rem;
      font-weight: 600;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
    }

    /* ================= MOBILE RESPONSIVENESS ================= */
    @media (max-width: 768px) {
      .container {
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }

      .sidebar {
        width: 100%;
        border-right: none;
        display: flex;
        /* Default show sidebar */
      }

      .main-chat {
        display: none;
        /* Default hide chat */
        width: 100%;
        height: 100%;
      }

      /* Toggle Classes for Mobile */
      .sidebar.hidden {
        display: none !important;
      }

      .main-chat.active {
        display: flex !important;
      }

      #mobileBackBtn {
        display: block !important;
        /* Show back button */
      }

      .mobile-hidden {
        display: none !important;
      }

      /* Adjust Headers */
      .app-header {
        padding: 10px 15px;
      }

      .app-header span {
        font-size: 1.4rem;
      }

      .wb-dashboard,
      .wb-ui {
        z-index: 6000;
        /* Ensure on top of sidebar */
      }
    }

    /* Desktop Back Button Hide */
    #mobileBackBtn {
      display: none;
      background: transparent;
      font-size: 1.5rem;
      border: none;
      color: var(--text-main);
      margin-right: 10px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Auth Screens -->
    <div id="authScreen" class="auth-screen">
      <h2>Alter</h2>
      <div id="registerForm">
        <h3>Register</h3>
        <input type="text" id="regUsername" placeholder="Username" />
        <input type="email" id="regEmail" placeholder="Email" />
        <input type="password" id="regPassword" placeholder="Password" />
        <button onclick="register()">Register</button>
        <p><a href="#" onclick="showLogin()">Already have an account?</a></p>
      </div>
      <div id="loginForm" class="hidden">
        <h3>Login</h3>
        <input type="email" id="loginEmail" placeholder="Email" />
        <input type="password" id="loginPassword" placeholder="Password" />
        <button onclick="login()">Login</button>
        <p><a href="#" onclick="showRegister()">Need an account?</a></p>
      </div>
      <div id="otpForm" class="hidden">
        <h3>Verify OTP</h3>
        <p>Enter the 6-digit code sent to your email</p>
        <input type="text" id="otpCode" placeholder="123456" maxlength="6" />
        <button onclick="verifyOTP()">Verify</button>
        <p><a href="#" onclick="showRegister()">Change email?</a></p>
      </div>
    </div>

    <!-- Main App -->
    <div id="app" class="hidden" style="display:flex; flex-direction:column; height:100%;">
      <div class="app-header">
        <div class="logo-container">
          <img src="static/alter_logo.png" alt="Alter">
          <span>Alter</span>
        </div>
        <div>
          <button onclick="showCreateGroup()" style="font-size:0.9em;padding:6px 10px;margin-right:5px;">+
            Group</button>
          <button onclick="showSettings()" style="font-size:0.9em;padding:6px 10px;margin-right:5px;">Settings</button>
          <button onclick="logout()" style="font-size:0.9em;padding:6px 10px;">Logout</button>
        </div>
      </div>

      <div class="layout-wrapper">
        <div id="sidebar" class="sidebar">
          <div style="padding:10px;">
            <!-- Tools remain but maybe less prominent or integrated? User said create sidebar LIKE chats/groups/status -->
            <!-- We keep tools at top or bottom? Let's keep top for now as "Apps" -->
            <div style="display:flex; gap:5px; margin-bottom:10px;">
              <button onclick="showWhiteboardDashboard()" style="flex:1; font-size:0.8rem; padding:8px;">üé® WB</button>
              <button onclick="showNotepadDashboard()" style="flex:1; font-size:0.8rem; padding:8px;">üìù Note</button>
            </div>
          </div>

          <!-- TABS -->
          <div class="sidebar-tabs">
            <div class="sidebar-tab active" onclick="switchSidebarTab('chats')">Chats</div>
            <div class="sidebar-tab" onclick="switchSidebarTab('groups')">Groups</div>
            <div class="sidebar-tab" onclick="switchSidebarTab('status')">Status</div>
          </div>

          <!-- CONTENT: CHATS -->
          <div id="tab-chats" class="sidebar-content active">
            <div style="padding:10px;">
              <button onclick="showAddFriend()">+ Add Friend</button>
            </div>
            <ul id="chatList" class="chat-list"></ul>
            <div id="incomingRequests"></div>
          </div>

          <!-- CONTENT: GROUPS -->
          <div id="tab-groups" class="sidebar-content">
            <!-- No built-in list logic yet, assuming groupList is populated same as chats -->
            <div style="padding:10px;">
              <button onclick="showCreateGroup()">+ New Group</button>
            </div>
            <ul id="groupList" class="chat-list"></ul>
          </div>

          <!-- CONTENT: STATUS -->
          <div id="tab-status" class="sidebar-content">
            <div style="padding:10px; border-bottom:1px solid rgba(255,255,255,0.1);">
              <div class="status-item" onclick="triggerStatusUpload()">
                <div class="status-ring">
                  <img id="myStatusImg" src="" onerror="this.src='https://ui-avatars.com/api/?name=Me'">
                  <div
                    style="position:absolute; bottom:0; right:0; background:green; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-size:1rem; border:2px solid #1e293b;">
                    +</div>
                </div>
                <div>
                  <div style="font-weight:600;">My Status</div>
                  <div style="font-size:0.8rem; color:var(--text-muted);">Tap to add update</div>
                </div>
              </div>
              <input type="file" id="statusUploadInput" hidden accept="image/*,video/*"
                onchange="handleStatusFile(this)">
            </div>

            <div style="padding:10px 16px; font-size:0.8rem; font-weight:700; color:var(--text-muted);">RECENT UPDATES
            </div>
            <div id="statusList">
              <!-- Status items go here -->
            </div>
          </div>
        </div>

        <div id="chatArea" class="main-chat hidden">
          <div id="chat-background"></div>
          <div id="chatHeader" class="chat-header">
            <button id="mobileBackBtn" onclick="backToSidebar()">‚Üê</button>
            <input type="file" id="dpUpload" hidden onchange="uploadDP(this)" />
            <button onclick="document.getElementById('dpUpload').click()">Change DP</button>
            <button id="staticChangeGroupDpBtn" class="hidden"
              onclick="document.getElementById('groupIconUpload').click()">Group Icon (Sigma)</button>
            <div style="display:flex;align-items:center;gap:10px;">
              <img id="chatDp" class="dp" />
              <span>Select a chat</span>
            </div>
            <div class="chat-actions">
              <button id="callBtn" class="hidden" onclick="startCall()" title="Call">üìû</button>
              <button id="whiteboardBtn" class="hidden" onclick="openChatWhiteboard()" title="Collaborate">üé®</button>
              <button id="deleteChatBtn" class="hidden" onclick="deleteCurrentChat()" title="Delete Chat">üóë</button>
              <button id="deleteGroupBtn" class="hidden" onclick="deleteCurrentGroup()" title="Delete Group">üóë</button>
              <button id="groupMembersBtn" class="hidden" onclick="showGroupMembers()" title="Members">üë•</button>
              <input type="file" id="groupIconUpload" hidden onchange="uploadGroupIcon(this)" />
            </div>
          </div>
          <div id="messages" class="messages"></div>
          <div class="input-area">
            <select id="msgTimer" style="margin-right:5px;padding:10px;border-radius:20px;border:1px solid #ccc;">
              <option value="">Off</option>
              <option value="10">10s</option>
              <option value="60">1m</option>
              <option value="300">5m</option>
              <option value="3600">1h</option>
            </select>
            <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)" />
            <button onclick="sendMessage()">Send</button>
            <button onclick="document.getElementById('imageUpload').click()" style="margin-left:5px;">üì∑</button>
            <input type="file" id="imageUpload" accept="image/*" onchange="uploadImage(this)" style="display:none;" />
          </div>
        </div>

        <!-- Whiteboard Dashboard -->
        <div id="whiteboardDashboard" class="wb-dashboard hidden">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0;">My Whiteboards</h2>
            <button onclick="backToSidebar()" class="secondary-btn">Back to Chat</button>
          </div>
          <div style="margin-bottom:20px;">
            <button onclick="createNewWhiteboard()"
              style="background:var(--primary-gradient); color:white; padding:10px 20px; border-radius:30px; font-weight:600;">+
              New Whiteboard</button>
          </div>
          <div id="wbGrid" class="wb-grid">
            <!-- WB Cards loaded via JS -->
          </div>
        </div>

        <!-- Notepad Dashboard -->
        <div id="notepadDashboard" class="wb-dashboard hidden">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0;">My Notepads</h2>
            <button onclick="backToSidebar()" class="secondary-btn">Back to Chat</button>
          </div>
          <div style="margin-bottom:20px;">
            <button onclick="createNotepad()"
              style="background:var(--primary-gradient); color:white; padding:10px 20px; border-radius:30px; font-weight:600;">+
              New Note</button>
          </div>
          <div id="notepadGrid" class="wb-grid">
            <!-- Note Cards loaded via JS -->
          </div>
        </div>

        <!-- Notepad Editor UI (Standalone) -->
        <div id="notepadUI" class="wb-ui hidden" style="display:none; flex-direction:column;">
          <div class="wb-header">
            <input type="text" id="noteTitle" value="Untitled Note" class="notepad-title-input"
              placeholder="Note Title">
            <div style="display:flex; gap:10px; align-items:center;">
              <span id="noteSaveStatus" style="font-size:0.8rem; color:var(--text-muted);">Saved</span>
              <button onclick="openDeltaModal()"
                style="background:linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color:black; padding:8px 20px; border-radius:20px; font-weight:bold; box-shadow:0 0 10px rgba(255, 215, 0, 0.3);">‚ú®
                DELTA</button>
              <button onclick="saveNotepad()"
                style="background:var(--primary-gradient); color:white; padding:8px 20px; border-radius:20px;">Save</button>
              <button onclick="downloadNotepadPDF()"
                style="background:rgba(255, 255, 255, 0.1); color:white; padding:8px 15px; border-radius:15px; font-size:1.2rem;"
                title="Download PDF">üìÑ</button>
              <button onclick="openShareModal('notepad', currentNoteId)"
                style="background:rgba(255, 255, 255, 0.1); color:white; padding:8px 15px; border-radius:15px; font-size:1.2rem;"
                title="Share Copy">üì§</button>
              <button onclick="closeNotepadUI()" class="secondary-btn"
                style="background:rgba(255, 255, 255, 0.1); color:var(--text-main); border:1px solid var(--border-elegant);">Exit</button>
            </div>
          </div>
          <div style="flex:1; padding:20px;">
            <textarea id="noteContent" class="notepad-textarea" placeholder="Type something..."></textarea>
          </div>
        </div>

        <!-- Welcome Screen (When no chat selected) -->
        <div id="welcomeScreen"
          style="flex:1; display:flex; justify-content:center; align-items:center; color:#888; background:rgba(255,255,255,0.5);">
          <div style="text-align:center;">
            <div style="font-size:3rem; margin-bottom:1rem;">üëã</div>
            <h2>Welcome to Alter</h2>
            <p>Select a chat to start messaging</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Viewer -->
    <div id="statusViewer">
      <div id="statusProgressContainer"></div>
      <div style="position:absolute; top:20px; left:20px; z-index:5002; display:flex; align-items:center;">
        <img id="statusViewDp" src=""
          style="width:40px; height:40px; border-radius:50%; margin-right:10px; border:1px solid white;">
        <div>
          <div id="statusViewName" style="color:white; font-weight:600;">User</div>
          <div id="statusViewTime" style="color:rgba(255,255,255,0.7); font-size:0.8rem;">Just now</div>
        </div>
      </div>
      <button onclick="closeStatusViewer()"
        style="position:absolute; top:20px; right:20px; z-index:5002; background:none; border:none; color:white; font-size:2rem;">‚úï</button>

      <div id="statusContentArea"></div>

      <div class="status-like-container">
        <div id="statusLikeBtn" class="status-like-btn"
          onclick="toggleStatusLike(currentStatusGroup.statuses[currentViewerItemIdx].id)">ü§ç</div>
        <div id="statusLikeCount" class="status-like-count"></div>
      </div>

      <div id="statusDeleteBtnContainer" class="hidden" style="position:absolute; top:20px; right:60px; z-index:5003;">
        <button onclick="deleteStatus(currentStatusGroup.statuses[currentViewerItemIdx].id)"
          style="background:rgba(0,0,0,0.5); border:none; color:white; font-size:1.5rem; cursor:pointer; border-radius:50%; width:40px; height:40px; display:flex; align-items:center; justify-content:center;">üóëÔ∏è</button>
      </div>
    </div>

    <!-- Modals -->
    <div id="addFriendModal" class="hidden modal">
      <div class="modal-content">
        <h3>Add Friend</h3>
        <div style="position:relative;">
          <input type="text" id="friendUsername" placeholder="Enter username..." style="width:100%; margin-bottom: 5px;"
            oninput="searchUsers(this.value)" autocomplete="off" />
          <div id="searchResults"></div>
        </div>
        <div style="margin-top:20px; display: flex; gap: 10px;">
          <button onclick="sendFriendRequest()" style="flex:1;">Send Request</button>
          <button onclick="hideAddFriend()" class="secondary-btn" style="flex:1;">Cancel</button>
        </div>
      </div>
    </div>

    <div id="createGroupModal" class="hidden modal">
      <div class="modal-content">
        <h3>Create Group</h3>
        <input type="text" id="groupName" placeholder="Group name" style="width:100%; margin-bottom: 10px;" />
        <label style="display:block; margin-bottom:5px; color:var(--text-muted); font-size:0.9rem;">Select
          Friends:</label>
        <div class="member-list" id="friendSelectionList"
          style="max-height: 200px; margin-bottom: 20px; overflow-y: auto;"></div>
        <div style="display: flex; gap: 10px;">
          <button onclick="createGroup()" style="flex:1;">Create</button>
          <button onclick="hideCreateGroup()" class="secondary-btn" style="flex:1;">Cancel</button>
        </div>
      </div>
    </div>

    <div id="groupMembersModal" class="hidden modal">
      <div class="modal-content">
        <h3>Group Members</h3>
        <div class="member-list" id="groupMembersList"></div>
        <div style="margin-top:20px; display:flex; gap:10px;">
          <button id="addMemberBtn" onclick="showAddMemberModal()" style="flex:1;" class="hidden">Add Member</button>
          <button onclick="hideGroupMembers()" class="secondary-btn" style="flex:1;">Close</button>
        </div>
      </div>
    </div>

    <div id="addMemberModal" class="hidden modal" style="z-index: 1100;"> <!-- Higher z-index -->
      <div class="modal-content">
        <h3>Add Member</h3>
        <div class="member-list" id="addMemberFriendList" style="max-height: 200px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('addMemberModal').classList.add('hidden')" class="secondary-btn"
            style="width:100%;">Cancel</button>
        </div>
      </div>
    </div>



    <div id="reactionDetailsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Reactions</h3>
        <div class="member-list" id="reactionDetailsList" style="max-height: 300px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('reactionDetailsModal').classList.add('hidden')"
            class="secondary-btn" style="width:100%;">Close</button>
        </div>
      </div>
    </div>

    <div id="seenDetailsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Seen By</h3>
        <div class="member-list" id="seenDetailsList" style="max-height: 300px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('seenDetailsModal').classList.add('hidden')" class="secondary-btn"
            style="width:100%;">Close</button>
        </div>
      </div>
    </div>

    <div id="shareItemModal" class="hidden modal">
      <div class="modal-content">
        <h3>Share With</h3>
        <p style="color:var(--text-muted); font-size:0.9rem; margin-bottom:10px;">Select a friend to send a copy.</p>
        <div class="member-list" id="shareFriendList" style="max-height: 300px; overflow-y: auto;"></div>
        <div style="margin-top:20px;">
          <button onclick="document.getElementById('shareItemModal').classList.add('hidden')" class="secondary-btn"
            style="width:100%;">Cancel</button>
        </div>
      </div>
    </div>

    <!-- DELTA AI Modal -->
    <div id="deltaModal" class="hidden modal" style="z-index: 5000;">
      <div class="modal-content">
        <h3>‚ú® DELTA AI</h3>
        <p style="color:var(--text-muted); font-size:0.9rem; margin-bottom:15px;">Powered by Gemini Flash</p>

        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px;">
          <button onclick="triggerDelta('summarize')" class="secondary-btn">üìù Summarize</button>
          <button onclick="triggerDelta('action_items')" class="secondary-btn">‚úÖ Action Items</button>
          <button onclick="triggerDelta('polish')" class="secondary-btn">üé© Polish / Professional</button>
          <button onclick="triggerDelta('expand')" class="secondary-btn">üß† Brainstorm / Expand</button>
          <button onclick="triggerDelta('explain_code')" class="secondary-btn">üíª Explain Code</button>
        </div>

        <div style="border-top:1px solid rgba(255,255,255,0.1); padding-top:10px; margin-bottom:15px;">
          <label style="display:block;margin-bottom:5px;font-size:0.9rem;">Ask a Question about this note:</label>
          <div style="display:flex; gap:5px;">
            <input type="text" id="deltaQuery" placeholder="e.g. What is the deadline?" style="flex:1;">
            <button onclick="triggerDelta('qa')">Ask</button>
          </div>
        </div>

        <div id="deltaResultArea" class="hidden"
          style="background:rgba(0,0,0,0.3); padding:10px; border-radius:10px; margin-bottom:15px; max-height:200px; overflow-y:auto; font-size:0.9rem; white-space:pre-wrap;">
        </div>

        <div style="display:flex; justify-content:flex-end;">
          <button onclick="document.getElementById('deltaModal').classList.add('hidden')"
            class="secondary-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- ... existing modals ... -->
    <div id="settingsModal" class="hidden modal">
      <div class="modal-content">
        <h3>Settings</h3>
        <div style="display:flex;align-items:center;margin-bottom:20px;">
          <div class="dp-container" onclick="document.getElementById('settingsDpUpload').click()">
            <img id="settingsDp" class="dp" src="https://ui-avatars.com/api/?name=User" />
            <div class="dp-overlay"><span>üì∑</span></div>
          </div>
          <div>
            <h4 id="settingsUsernameDisplay" style="margin:0; font-size:1.2rem;">User</h4>
            <span style="font-size:0.8rem; color:var(--text-muted);">Click image to change</span>
            <input type="file" id="settingsDpUpload" hidden onchange="uploadSettingsDP(this)" />
          </div>
        </div>
        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Username</label>
        <input type="text" id="settingsUsername" disabled style="margin-bottom:15px; opacity:0.7;" />
        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Email</label>
        <input type="text" id="settingsEmail" disabled style="margin-bottom:15px; opacity:0.7;" />

        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <label style="color:var(--text-muted);">Appearance</label>
          <button id="themeToggleBtn" onclick="toggleTheme()" style="width:auto; padding:6px 12px; font-size:0.9rem;">‚òÄÔ∏è
            Light Mode</button>
        </div>

        <label style="display:block; margin-bottom:10px; color:var(--text-muted);">Chat Wallpaper</label>
        <div class="theme-grid">
          <div class="theme-option" onclick="selectTheme('default')" data-theme="default" title="Default (None)"
            style="background:var(--bg-gradient); display:flex;align-items:center;justify-content:center;">üö´</div>
          <div class="theme-option" onclick="selectTheme('bg1')" data-theme="bg1" title="Background 1"
            style="background-image:url('static/bg1.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg2')" data-theme="bg2" title="Background 2"
            style="background-image:url('static/bg2.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg3')" data-theme="bg3" title="Background 3"
            style="background-image:url('static/bg3.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg4')" data-theme="bg4" title="Background 4"
            style="background-image:url('static/bg4.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg5')" data-theme="bg5" title="Background 5"
            style="background-image:url('static/bg5.png');"></div>
          <div class="theme-option" onclick="selectTheme('bg6')" data-theme="bg6" title="Background 6"
            style="background-image:url('static/bg6.png');"></div>
        </div>

        <label style="display:block; margin-bottom:5px; color:var(--text-muted);">Description (About)</label>
        <input type="text" id="settingsDescription" placeholder="Hey there! I am using Alter."
          style="margin-bottom:20px;" />
        <div style="display: flex; gap: 10px;">
          <button onclick="updateProfileDescription()" style="flex:1;">Save</button>
          <button onclick="hideSettings()" class="secondary-btn" style="flex:1;">Close</button>
        </div>
      </div>
    </div>
  </div>




  <div id="emojiPicker"></div>

  <!-- Audio Elements -->
  <audio id="remoteAudio" autoplay playsinline controls style="width:0;height:0;opacity:0;position:absolute;"></audio>
  <audio id="ringtone" src="https://assets.mixkit.co/active_storage/sfx/1359/1359-preview.mp3" loop></audio>

  <!-- Incoming Call Modal -->
  <div id="incomingCallModal" class="hidden modal" style="z-index: 2500;">
    <div class="modal-content" style="text-align:center;">
      <h3 id="incomingCallerName">Unknown</h3>
      <p>is calling you...</p>
      <div style="margin-top:20px; display:flex; justify-content:center; gap:20px;">
        <button onclick="acceptCall()"
          style="background:#22c55e; color:white; padding:15px 30px; border-radius:30px; font-size:1.1rem;">Accept</button>
        <button onclick="rejectCall()"
          style="background:#ef4444; color:white; padding:15px 30px; border-radius:30px; font-size:1.1rem;">Reject</button>
      </div>
    </div>
  </div>

  <!-- In-Call Overlay -->
  <div id="callOverlay" class="hidden">
    <img id="callAvatar" class="call-avatar" src="https://ui-avatars.com/api/?name=User" />
    <h3 id="callName" style="color:white; font-size:2rem; margin-bottom:10px;">User</h3>
    <p id="callStatus" style="color:#aaa; margin-bottom:30px;">Connected</p>

    <!-- Audio Helper -->
    <div id="audioHelper" class="hidden"
      style="position:absolute; top:20px; left:50%; transform:translateX(-50%); z-index:3000;">
      <button onclick="forcePlayAudio()"
        style="background:#ef4444; color:white; padding:10px 20px; border-radius:30px; border:2px solid white; font-weight:bold; box-shadow:0 4px 12px rgba(0,0,0,0.5); animation: pulse 2s infinite;">
        üîá TAP TO UNMUTE AUDIO
      </button>
    </div>

    <div class="call-actions">
      <button id="mainMuteBtn" class="btn-mute" onclick="toggleMute()">üé§</button>
      <button class="btn-screen" onclick="startScreenShare()"
        style="background:rgba(255,255,255,0.2);color:white;">üñ•Ô∏è</button>
      <button onclick="minimizeCall()"
        style="background:rgba(255,255,255,0.2); color:white; border-radius:50%; width:60px; height:60px; font-size:1.5rem; border:none; transition:transform 0.2s; display:flex; align-items:center; justify-content:center;">üîΩ</button>
      <button class="btn-end" onclick="endCall()">üìû</button>
    </div>

    <!-- Video Element for Screen Share -->
    <video id="remoteVideo" autoplay playsinline
      style="max-width:90%; max-height:60vh; border-radius:12px; margin-top:20px; display:none; border:2px solid rgba(255,255,255,0.2);"></video>
  </div>

  <!-- Mini Call Widget -->
  <div id="miniCallWidget" class="hidden"
    style="position:fixed; bottom:20px; right:20px; background:#1e293b; border:1px solid rgba(255,255,255,0.2); border-radius:16px; padding:10px 20px; display:flex; align-items:center; gap:15px; z-index:4000; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
    <div
      style="width:40px; height:40px; border-radius:50%; background:var(--primary-gradient); display:flex; align-items:center; justify-content:center; animation:pulse 2s infinite;">
      üìû</div>
    <div style="display:flex; flex-direction:column;">
      <span style="font-weight:bold; font-size:0.9rem; color:white;" id="miniCallName">User</span>
      <span style="font-size:0.75rem; color:#4ade80;">Active Call</span>
    </div>
    <div style="display:flex; gap:10px; margin-left:10px;">
      <button onclick="maximizeCall()"
        style="background:rgba(255,255,255,0.1); border:none; color:white; border-radius:50%; width:36px; height:36px;">‚§¢</button>
      <button id="miniMuteBtn" onclick="toggleMute()"
        style="background:rgba(255,255,255,0.1); border:none; color:white; border-radius:50%; width:36px; height:36px;">üé§</button>
      <button onclick="endCall()"
        style="background:#ef4444; width:36px; height:36px; border-radius:50%; color:white; border:none; display:flex; align-items:center; justify-content:center;">‚úñ</button>
    </div>
  </div>

  <!-- Whiteboard UI (Standalone) -->
  <div id="whiteboardUI" class="wb-ui hidden">
    <div class="wb-header">
      <input type="text" id="wbTitle" value="Untitled Whiteboard" onchange="saveWhiteboardName()">
      <div style="display:flex; gap:10px; align-items:center;">
        <span id="wbSaveStatus" style="font-size:0.8rem; color:var(--text-muted);">Saved</span>
        <button onclick="saveWhiteboard()"
          style="background:var(--primary-gradient); color:white; padding:8px 20px; border-radius:20px;">Save</button>
        <button onclick="openShareModal('whiteboard', wbState.id)"
          style="background:rgba(255, 255, 255, 0.1); color:white; padding:8px 15px; border-radius:15px; font-size:1.2rem;"
          title="Share Copy">üì§</button>
        <button onclick="closeWhiteboardUI()" class="secondary-btn"
          style="background:rgba(255, 255, 255, 0.1); color:var(--text-main); border:1px solid var(--border-elegant);">Exit</button>
      </div>
    </div>

    <!-- Toolbar -->
    <div class="wb-toolbar">
      <button class="wb-tool-btn" id="tool-select" onclick="setTool('select')" title="Select & Move">üëÜ</button>
      <button class="wb-tool-btn active" id="tool-pen" onclick="setTool('pen')" title="Pen">‚úèÔ∏è</button>
      <button class="wb-tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Eraser">üßπ</button>

      <button class="wb-tool-btn" id="tool-shapes" onclick="toggleShapePicker()" title="Shapes">üî∂</button>

      <div style="height:1px; background:rgba(255,255,255,0.1); margin:5px 0;"></div>

      <input type="color" id="wbColorPicker" value="#000000" onchange="setColor(this.value)"
        style="width:30px; height:30px; padding:0; border:none; border-radius:50%; overflow:hidden;">
      <input type="range" id="wbSizeSlider" min="1" max="20" value="4" oninput="setSize(this.value)"
        style="width:100%;">

      <!-- Shape Picker Popover -->
      <div id="wbShapePicker" class="wb-shape-picker">
        <!-- Shapes injected by JS -->
      </div>
    </div>

    <div class="wb-canvas-container" id="wbCanvasContainer" style="position:relative;">
      <canvas id="wbCanvasNew"></canvas>
    </div>

  </div>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // ... existing ...

    // Add force play function globally
    function forcePlayAudio() {
      const aud = document.getElementById('remoteAudio');
      if (aud) {
        aud.play().then(() => {
          document.getElementById('audioHelper').classList.add('hidden');
          console.log("Audio started manually");
        }).catch(e => alert("Still cannot play audio: " + e.message));
      }
    }

    // ... (rest of code) ...

    // Updated createPeerConnection function (Need to replace the old one lower down)


    function formatTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    async function showSeenDetails(messageId) {
      try {
        const list = document.getElementById('seenDetailsList');
        list.innerHTML = 'Loading...';
        document.getElementById('seenDetailsModal').classList.remove('hidden');

        const records = await api(`/messages/${messageId}/seen`);
        list.innerHTML = '';

        if (records.length === 0) {
          list.innerHTML = '<div style="padding:10px;text-align:center;color:#888">No views yet</div>';
          return;
        }

        records.forEach(r => {
          const div = document.createElement('div');
          div.className = 'chat-item';
          div.style.cursor = 'default';
          div.innerHTML = `
                   <img src="${avatar(r.profile_image, r.username)}" class="dp">
                   <div style="flex:1;">
                       <span style="font-weight:600;">${r.username}</span>
                       <div style="font-size:0.8rem;color:#888;">${formatTime(r.seen_at)}</div>
                   </div>
                `;
          list.appendChild(div);
        });
      } catch (e) {
        alert("Failed to load: " + e.message);
      }
    }


    // Config
    const API_BASE = window.location.origin;


    let currentUser = null;
    let currentChatId = null;
    let currentChatType = null; // 'private' or 'group'
    let socket = null;
    const EMOJIS = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üò°', 'üëè', 'üôè', 'üî•', 'üíØ'];

    // DOM Elements
    const authScreen = document.getElementById('authScreen');
    const app = document.getElementById('app');
    const registerForm = document.getElementById('registerForm');
    const loginForm = document.getElementById('loginForm');
    const otpForm = document.getElementById('otpForm');
    const chatList = document.getElementById('chatList');
    const groupList = document.getElementById('groupList');
    const incomingRequests = document.getElementById('incomingRequests');
    const chatArea = document.getElementById('chatArea');
    const chatHeader = document.getElementById('chatHeader');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const emojiPicker = document.getElementById('emojiPicker');
    const groupMembersBtn = document.getElementById('groupMembersBtn');
    const deleteChatBtn = document.getElementById('deleteChatBtn');
    const deleteGroupBtn = document.getElementById('deleteGroupBtn');

    // Selected friends for group creation
    let selectedFriendIds = [];

    // Auth UI Helpers
    function showRegister() {
      registerForm.classList.remove('hidden');
      loginForm.classList.add('hidden');
      otpForm.classList.add('hidden');
    }
    function showLogin() {
      loginForm.classList.remove('hidden');
      registerForm.classList.add('hidden');
      otpForm.classList.add('hidden');
    }
    function showOTP() {
      otpForm.classList.remove('hidden');
      registerForm.classList.add('hidden');
      loginForm.classList.add('hidden');
    }

    function avatar(url, name = "User") {
      return url || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=128C7E&color=fff`;
    }

    async function api(endpoint, options = {}) {
      const token = localStorage.getItem('token');
      const headers = { 'Content-Type': 'application/json', ...(options.headers || {}) };

      // Determine if this is a public endpoint that doesn't need auth
      const publicEndpoints = ['/login', '/register', '/verify-otp'];
      const cleanEndpoint = endpoint.split('?')[0]; // Ignore query params for check

      if (token && !publicEndpoints.includes(cleanEndpoint)) {
        headers['Authorization'] = `Bearer ${token}`;
        // console.log(`Attaching token for ${endpoint}`);
      } else {
        // console.log(`Skipping token for ${endpoint} (Public or No Token)`);
      }

      console.log(`API Call to ${endpoint}`, { hasToken: !!token, headers });
      const res = await fetch(API_BASE + endpoint, { ...options, headers });
      if (!res.ok) {
        let errMsg = 'Request failed';
        try {
          const err = await res.json();
          errMsg = err.msg || errMsg;
          if (res.status === 401 && errMsg === 'Token has expired') {
            logout(); // Auto logout on expire
            return;
          }
        } catch (e) { }
        throw new Error(errMsg);
      }
      return res.json();
    }

    async function deleteCurrentGroup() {
      if (!currentChatId || currentChatType !== 'group') return;
      if (!confirm("Delete this group permanently?")) return;
      try {
        await api(`/groups/${currentChatId}/delete`, { method: 'DELETE' });
        document.getElementById('welcomeScreen').classList.remove('hidden'); // Show welcome
        chatArea.classList.add('hidden');
        currentChatId = null;
        currentChatType = null;
        loadGroups();
        chatHeader.querySelector('span').textContent = 'Select a chat';
        deleteGroupBtn.classList.add('hidden');
        groupMembersBtn.classList.add('hidden');
        alert("Group deleted");
      } catch (e) {
        alert("Delete failed: " + e.message);
      }
    }

    // Auth Functions
    async function register() {
      const username = document.getElementById('regUsername').value;
      const email = document.getElementById('regEmail').value;
      const password = document.getElementById('regPassword').value;
      try {
        const data = await api('/register', { method: 'POST', body: JSON.stringify({ username, email, password }) });

        if (data.msg && data.msg.includes('verified automatically')) {
          alert('Registration successful! You have been verified automatically.');
          showLogin();
        } else {
          alert('Registration successful! Check your email for OTP.');
          showOTP();
        }
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }

    async function verifyOTP() {
      const email = document.getElementById('regEmail').value;
      const otp = document.getElementById('otpCode').value;
      try {
        await api('/verify-otp', { method: 'POST', body: JSON.stringify({ email, otp }) });
        alert('OTP verified! You can now log in.');
        showLogin();
      } catch (e) {
        alert('Invalid OTP: ' + e.message);
      }
    }

    async function login() {
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      try {
        const data = await api('/login', { method: 'POST', body: JSON.stringify({ email, password }) });
        if (!data.access_token) {
          alert('Server did not return a token.');
          return;
        }
        localStorage.setItem('token', data.access_token);
        initApp();
      } catch (e) {
        alert('Login failed: ' + e.message);
      }
    }

    async function initApp() {
      const token = localStorage.getItem('token');
      if (!token || token === 'undefined' || token === 'null') {
        localStorage.removeItem('token');
        return showLogin();
      }
      try {
        const profile = await api('/profile');
        currentUser = profile;
        authScreen.classList.add('hidden');
        app.classList.remove('hidden');
        connectSocket(token);
        loadChats();
        loadGroups();
        loadIncomingRequests();
      } catch (e) {
        console.error("Profile error:", e.message);
        localStorage.removeItem('token');
        showLogin();
      }
    }

    function logout() {
      localStorage.removeItem('token');
      if (socket) socket.disconnect();
      authScreen.classList.remove('hidden');
      app.classList.add('hidden');
      showLogin();
    }

    // Socket.IO
    function connectSocket(token) {
      socket = io(window.location.origin, {
        query: { token },
        transports: ['websocket'],
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000
      });

      socket.on('connect', () => console.log('Socket connected'));
      socket.on('new_message', addMessageToUI);
      socket.on('new_group_message', addMessageToUI);
      socket.on('reaction_update', (data) => {
        // console.log("Socket: reaction_update received:", data);
        updateReactionsUI(data.message_id, data.reactions);
      });
      socket.on('message_seen_update', (data) => {
        updateSeenUI(data.message_id, data.username);
      });
      socket.on('error', (data) => alert('Socket error: ' + data.msg));

      setupCallSocketListeners();
    }

    // Seen Observer
    const seenObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const msgIdStr = entry.target.id.replace('msg-', '');
          const msgId = parseInt(msgIdStr);

          // If it's my own message, I don't "see" it typically, or duplicates.
          // Simple logic: just emit mark_seen
          if (!isNaN(msgId) && socket && currentUser) {
            if (entry.target.dataset.senderId != currentUser.id) {
              // Only mark others' messages as seen
              // console.log("Marking seen:", msgId);
              socket.emit('mark_seen', { message_id: msgId });
              seenObserver.unobserve(entry.target); // Only mark once
            }
          }
        }
      });
    }, { threshold: 0.5 });

    // Load Chats and Groups
    async function loadChats() {
      const friends = await api('/friends');
      chatList.innerHTML = '';
      friends.forEach(friend => {
        const li = document.createElement('li');
        li.className = 'chat-item';
        li.innerHTML = `
          <img src="${avatar(friend.profile_image, friend.username)}" class="dp">
          <span>${friend.username}</span>
        `;
        li.onclick = () => openPrivateChat(friend.id, friend.username, friend.profile_image);
        chatList.appendChild(li);
      });
    }

    async function loadGroups() {
      try {
        const groups = await api('/groups');
        groupList.innerHTML = '';
        groups.forEach(group => {
          const li = document.createElement('li');
          li.className = 'chat-item';
          // Use group image or default
          const icon = group.image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(group.name)}&background=random`;
          li.innerHTML = `
             <img src="${icon}" class="dp">
             <span>${group.name}</span>
          `;
          li.onclick = () => openGroupChat(group.id, group.name, icon);
          groupList.appendChild(li);
        });
      } catch (e) {
        console.error("Error loading groups:", e);
      }
    }

    async function loadIncomingRequests() {
      try {
        const requests = await api('/friend-requests/incoming');
        incomingRequests.innerHTML = '';
        if (requests.length > 0) {
          const h4 = document.createElement('h4');
          h4.textContent = 'Friend Requests';
          h4.style.padding = '10px 16px';
          h4.style.margin = '0';
          incomingRequests.appendChild(h4);

          requests.forEach(req => {
            const div = document.createElement('div');
            div.className = 'request-card';
            div.innerHTML = `
               <div style="display:flex; align-items:center;">
                   <img src="${avatar(null, req.username)}" class="dp" style="width:32px;height:32px;border-radius:50%;margin-right:10px;">
                   <span style="font-weight:600;">${req.username}</span>
               </div>
               <div>
                   <button onclick="acceptRequest(${req.request_id})" style="background:none; border:none; color:green; font-size:1.2rem; cursor:pointer; padding:5px;">‚úî</button>
                   <button onclick="rejectRequest(${req.request_id})" style="background:none; border:none; color:red; font-size:1.2rem; cursor:pointer; padding:5px;">‚úñ</button>
               </div>
            `;
            incomingRequests.appendChild(div);
          });
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function acceptRequest(requestId) {
      await api(`/friend-requests/${requestId}/accept`, { method: 'POST' });
      loadIncomingRequests();
      loadChats();
    }

    async function rejectRequest(requestId) {
      await api(`/friend-requests/${requestId}/reject`, { method: 'POST' });
      loadIncomingRequests();
    }

    // Group Creation
    function showCreateGroup() {
      document.getElementById('createGroupModal').classList.remove('hidden');
      loadFriendsForGroup();
    }

    function hideCreateGroup() {
      document.getElementById('createGroupModal').classList.add('hidden');
      selectedFriendIds = [];
    }

    async function loadFriendsForGroup() {
      const friends = await api('/friends');
      const list = document.getElementById('friendSelectionList');
      list.innerHTML = '';
      selectedFriendIds = [];
      friends.forEach(friend => {
        const div = document.createElement('div');
        div.className = 'member-item'; // This color is fixed in CSS now
        div.textContent = friend.username;
        div.dataset.userId = friend.id;
        div.style.padding = "5px"; // Add some padding
        div.style.cursor = "pointer";
        div.onclick = toggleFriendSelection;
        list.appendChild(div);
      });
    }

    function toggleFriendSelection(e) {
      const userId = parseInt(e.target.dataset.userId);
      const index = selectedFriendIds.indexOf(userId);
      if (index === -1) {
        selectedFriendIds.push(userId);
        e.target.style.background = 'var(--primary-gradient)'; // Visual feedback
        e.target.style.color = 'white';
      } else {
        selectedFriendIds.splice(index, 1);
        e.target.style.background = 'transparent';
        e.target.style.color = 'var(--text-main)';
      }
    }

    async function createGroup() {
      const groupName = document.getElementById('groupName').value;
      if (!groupName) {
        alert('Please enter a group name');
        return;
      }
      try {
        await api('/groups/create', {
          method: 'POST',
          body: JSON.stringify({
            group_name: groupName,
            member_ids: selectedFriendIds
          })
        });
        alert('Group created successfully!');
        hideCreateGroup();
        loadGroups();
      } catch (e) {
        alert('Error creating group: ' + e.message);
      }
    }

    function backToSidebar() {
      document.getElementById('sidebar').classList.remove('mobile-hidden');
      document.getElementById('chatArea').classList.remove('active');

      // Reset any inline styles if they exist
      document.querySelector('.sidebar').style.display = '';
      document.querySelector('.main-chat').style.display = '';
      document.getElementById('whiteboardDashboard').classList.add('hidden');
      document.getElementById('notepadDashboard').classList.add('hidden'); // Fix: Hide Notepad too
      document.getElementById('welcomeScreen').classList.remove('hidden');

      currentChatId = null;
      // Close editor if open
      document.getElementById('whiteboardUI').classList.add('hidden');
    }

    // Chat Functions
    async function openPrivateChat(friendId, friendName, friendDp) {
      document.getElementById('deleteChatBtn').classList.remove('hidden');
      document.getElementById('callBtn').classList.remove('hidden');
      // Whiteboard Disabled per user request
      // const wbBtn = document.getElementById('whiteboardBtn');
      // wbBtn.classList.remove('hidden');
      // wbBtn.onclick = () => openChatWhiteboard(); 
      document.getElementById('whiteboardBtn').classList.add('hidden'); // Ensure hidden

      deleteGroupBtn.classList.add('hidden');
      document.getElementById('staticChangeGroupDpBtn').classList.add('hidden');

      // Hide Welcome, Show Chat
      document.getElementById('welcomeScreen').classList.add('hidden');
      chatArea.classList.remove('hidden');

      // Mobile View Toggle
      document.getElementById('sidebar').classList.add('mobile-hidden');
      document.getElementById('chatArea').classList.add('active');

      try {
        // Fetch full profile to get Description (since friend list might be stale or simple)
        // Optimization: We could pass description from friend list click, but let's just fetch or use what we have.
        // For now, we update header with simple name.

        chatHeader.querySelector('span').innerHTML = `
            <div style="display:flex;flex-direction:column;">
                <span>${friendName}</span>
                <span id="headerStatus" style="font-size:0.75em;color:#666;font-weight:normal;"></span>
            </div>
        `;

        // Find friend in friend list to get description (avoids extra API call if we re-render friend list correctly)
        // But friend list isn't globally stored easily. Let's just rely on updated loadFriends?
        // Let's implement a quick fetch or just look at UI.
        // Better: openPrivateChat arguments are from click. Let's update arguments or fetch.
        // We will fetch /friends again to find this user or just accept it's missing until reload.

        const convData = await api(`/conversation-with/${friendId}`);
        currentChatId = convData.conversation_id;
        currentChatType = 'private';
        currentChatFriendId = friendId;


        document.getElementById('chatDp').src = avatar(friendDp, friendName);
        groupMembersBtn.classList.add('hidden');

        messagesDiv.innerHTML = '';

        // Fetch history
        const history = await api(`/chat/history/${currentChatId}`);
        messagesDiv.innerHTML = '';
        history.forEach(addMessageToUI);

        // Fetch Friend Details for Description update
        try {
          const friends = await api('/friends');
          const f = friends.find(u => u.id === friendId);
          if (f && f.description) {
            document.getElementById('headerStatus').textContent = f.description;
          }
        } catch (e) { }

        if (socket) {
          socket.emit('join_private_chat', { conversation_id: currentChatId });
        }
      } catch (e) {
        console.error("Error opening chat:", e);
        alert("Could not open chat: " + e.message);
      }
    }

    async function openGroupChat(id, name, iconUrl) {
      if (currentChatId === id && currentChatType === 'group') return;
      currentChatId = id;
      currentChatType = 'group';
      currentChatName = name;

      // Hide Welcome, Show Chat
      document.getElementById('welcomeScreen').classList.add('hidden');
      chatArea.classList.remove('hidden');

      // Mobile View Toggle
      document.getElementById('sidebar').classList.add('mobile-hidden');
      document.getElementById('chatArea').classList.add('active');


      // Reset UI
      document.getElementById('chatDp').src = iconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random`;
      document.getElementById('chatDp').parentElement.querySelector('span').textContent = name;
      messagesDiv.innerHTML = '';

      // Admin check for DP upload
      try {
        const members = await api(`/groups/${id}/members`);
        // Backend returns "id" for user id in this route
        const myMember = members.find(m => m.id === currentUser.id);
        const isAdmin = myMember && myMember.role === 'admin';

        if (isAdmin) {
          document.getElementById('staticChangeGroupDpBtn').classList.remove('hidden');
        } else {
          document.getElementById('staticChangeGroupDpBtn').classList.add('hidden');
        }
      } catch (e) { console.error(e); }

      document.getElementById('deleteChatBtn').classList.add('hidden');
      document.getElementById('callBtn').classList.add('hidden'); // Hide Call Button in Group

      // Whiteboard Disabled per user request
      // const wbBtn = document.getElementById('whiteboardBtn');
      // wbBtn.classList.remove('hidden'); 
      // wbBtn.onclick = () => openChatWhiteboard();
      document.getElementById('whiteboardBtn').classList.add('hidden');

      document.getElementById('deleteGroupBtn').classList.remove('hidden');
      document.getElementById('groupMembersBtn').classList.remove('hidden');

      socket.emit('join_group_chat', { group_id: id });
      loadGroupHistory(id);
    }

    async function uploadGroupIcon(input) {
      const file = input.files[0];
      if (!file || currentChatType !== 'group') return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      try {
        const res = await fetch(API_BASE + `/groups/${currentChatId}/upload-icon`, {
          method: "POST",
          headers: { Authorization: `Bearer ${token}` },
          body: form
        });
        if (res.ok) {
          alert("Group icon updated!");
          loadGroups(); // Refresh list
          // Update header logic would need reload or manual generic update
          const data = await res.json();
          document.getElementById('chatDp').src = data.url;
        } else {
          alert("Failed (Only Sigma admins can do this)");
        }
      } catch (e) { alert(e.message); }
    }

    async function loadGroupHistory(groupId) {
      try {
        const history = await api(`/group-chat/history/${groupId}`);
        messagesDiv.innerHTML = '';
        history.forEach(addMessageToUI);
        scrollToBottom();
      } catch (e) {
        console.error("Error loading group chat history:", e);
      }
    }

    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Settings
    function showSettings() {
      document.getElementById('settingsModal').classList.remove('hidden');
      document.getElementById('settingsUsername').value = currentUser.username;
      document.getElementById('settingsEmail').value = currentUser.email;
      document.getElementById('settingsDescription').value = currentUser.description || '';
      document.getElementById('settingsDp').src = avatar(currentUser.profile_image, currentUser.username);
      updateThemeBtn();
      updateThemeSelectionUI(); // Update UI for wallpaper selection
    }

    function hideSettings() {
      document.getElementById('settingsModal').classList.add('hidden');
    }

    async function updateProfileDescription() {
      const desc = document.getElementById('settingsDescription').value;
      try {
        await api('/profile/update', { method: 'POST', body: JSON.stringify({ description: desc }) });
        currentUser.description = desc;
        alert("Description updated!");
      } catch (e) { alert(e.message); }
    }

    async function uploadSettingsDP(input) {
      const file = input.files[0];
      if (!file) return;
      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        const res = await fetch(API_BASE + '/profile/upload-dp', {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
          body: formData
        });
        const data = await res.json();
        currentUser.profile_image = data.url;
        document.getElementById('settingsDp').src = data.url;
        alert("Profile picture updated!");
      } catch (e) {
        alert("Upload failed: " + e.message);
      }
    }

    // Group Members
    function showGroupMembers() {
      if (currentChatType !== 'group') return;
      document.getElementById('groupMembersModal').classList.remove('hidden');
      loadGroupMembers();
    }

    function hideGroupMembers() {
      document.getElementById('groupMembersModal').classList.add('hidden');
    }

    // Add Member Logic
    async function showAddMemberModal() {
      document.getElementById('addMemberModal').classList.remove('hidden');
      const friends = await api('/friends');
      const list = document.getElementById('addMemberFriendList');
      list.innerHTML = '';

      // Filter out existing members (Client-side optimization)
      // Ideally we fetch members first, but we can do it inside the loop or fetch fresh
      const members = await api(`/groups/${currentChatId}/members`);
      const memberIds = new Set(members.map(m => m.id));

      friends.forEach(friend => {
        if (memberIds.has(friend.id)) return;

        const div = document.createElement('div');
        div.className = 'member-item';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.innerHTML = `
                <span>${friend.username}</span>
                <button onclick="addMemberToGroup(${friend.id})" style="padding:4px 10px; font-size:0.8rem;">Add</button>
            `;
        list.appendChild(div);
      });

      if (list.children.length === 0) {
        list.innerHTML = '<div style="color:var(--text-muted); text-align:center; padding:10px;">No friends to add</div>';
      }
    }

    async function addMemberToGroup(userId) {
      try {
        await api(`/groups/${currentChatId}/add_member`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
        alert("Member added!");
        document.getElementById('addMemberModal').classList.add('hidden');
        loadGroupMembers(); // Refresh list
      } catch (e) {
        alert("Failed to add: " + e.message);
      }
    }

    async function loadGroupMembers() {
      try {
        const members = await api(`/groups/${currentChatId}/members`);
        const list = document.getElementById('groupMembersList');
        list.innerHTML = '';

        // Find my role to determine if I can kick/add
        const myMember = members.find(m => m.id === currentUser.id);
        const myRole = myMember ? myMember.role : 'member';

        // Show/Hide Add Button
        if (myRole === 'admin') {
          document.getElementById('addMemberBtn').classList.remove('hidden');
        } else {
          document.getElementById('addMemberBtn').classList.add('hidden');
        }

        members.forEach(member => {
          const div = document.createElement('div');
          div.className = 'member-item';
          div.style.display = 'flex';
          div.style.justifyContent = 'space-between';
          div.style.alignItems = 'center';
          div.style.color = "var(--text-main)"; // Ensure visible

          let actions = '';
          // Only show actions if I am admin and target is not me
          if (myRole === 'admin' && member.id !== currentUser.id) {
            if (member.role !== 'admin') {
              actions += `<button onclick="promoteMember(${member.id})" style="background:gold;color:black;padding:2px 6px;font-size:0.8em;margin-left:2px;">Promote</button>`;
            } else {
              actions += `<button onclick="demoteMember(${member.id})" style="background:orange;padding:2px 6px;font-size:0.8em;margin-left:2px;">Demote</button>`;
            }
            actions += `<button onclick="kickMember(${member.id})" style="background:red;color:white;padding:2px 6px;font-size:0.8em;margin-left:2px;">Kick</button>`;
          }

          const roleBadge = member.role === 'admin' ? '<span style="color:gold;font-weight:bold;margin-left:5px;">(Sigma)</span>' : '';
          const desc = member.description ? `<div style="font-size:0.75em;color:gray;">${member.description}</div>` : '';

          div.innerHTML = `
                <div style="display:flex;align-items:center;">
                    <img src="${avatar(member.custom_profile_image || member.profile_image, member.username)}" class="dp" style="width:32px;height:32px;margin-right:8px;">
                    <div>
                        <div style="font-weight:500;">${member.username} ${roleBadge}</div>
                        ${desc}
                    </div>
                </div>
                <div>${actions}</div>
            `;
          list.appendChild(div);
        });
      } catch (e) {
        console.error("Error loading group members:", e);
      }
    }

    async function kickMember(userId) {
      if (!confirm("Kick user?")) return;
      await api(`/groups/${currentChatId}/kick`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }
    async function promoteMember(userId) {
      await api(`/groups/${currentChatId}/promote`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }
    async function demoteMember(userId) {
      await api(`/groups/${currentChatId}/demote`, { method: 'POST', body: JSON.stringify({ user_id: userId }) });
      loadGroupMembers();
    }

    // Contextual DP
    async function uploadDP(input) {
      const file = input.files[0];
      if (!file) return;
      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        // If inside chat, use contextual route
        if (currentChatId) {
          const type = currentChatType; // 'private' or 'group'
          const res = await fetch(API_BASE + `/chat/${type}/${currentChatId}/upload-dp`, {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: formData
          });
          const data = await res.json();
          document.getElementById('chatDp').src = data.url; // Update header immediately
          alert("Chat DP updated!");
        } else {
          // Global Profile DP (fallback logic if called from profile settings)
          const res = await fetch(API_BASE + '/profile/upload-dp', {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: formData
          });
          alert("Global DP updated!");
        }
      } catch (e) {
        alert("Upload failed: " + e.message);
      }
    }

    // --- Sidebar Tabs & Status Logic ---
    function switchSidebarTab(tab) {
      document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));

      // Activate
      // Note: we identify tabs by onclick text or just hardcode classes? 
      // Simpler: querying by text content or index? Let's use event target in HTML or just selector
      // Actually I am passing string 'chats' etc.

      const tabs = document.querySelectorAll('.sidebar-tab');
      if (tab === 'chats') tabs[0].classList.add('active');
      if (tab === 'groups') tabs[1].classList.add('active');
      if (tab === 'status') {
        tabs[2].classList.add('active');
        loadStatuses(); // Reload when opening
      }

      document.getElementById(`tab-${tab}`).classList.add('active');
    }

    function triggerStatusUpload() {
      document.getElementById('statusUploadInput').click();
    }

    async function handleStatusFile(input) {
      const file = input.files[0];
      if (!file) return;

      // Video Duration Check
      if (file.type.startsWith('video/') || file.type === '') {
        try {
          const duration = await getVideoDuration(file);
          if (duration > 30.5) {
            alert("Video is too long! Max 30 seconds.");
            input.value = '';
            return;
          }
        } catch (e) {
          console.warn("Could not validate video duration (format might not be supported by browser):", e);
          // We allow it to proceed, assuming backend handles storage. 
          // Viewer might not play it if browser doesn't support it, but user asked for support.
        }
      }

      const formData = new FormData();
      formData.append('file', file);

      // ... (rest of upload)


      try {
        const token = localStorage.getItem('token');
        // Show loading?
        const res = await fetch(API_BASE + '/api/status', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: formData
        });
        if (res.ok) {
          alert("Status uploaded!");
          loadStatuses();
        } else {
          const errData = await res.json();
          alert(errData.msg || "Upload failed");
        }
      } catch (e) {
        alert("Error: " + e.message);
      }
    }

    function openMyStatusViewer() {
      // Mock a group for "Me"
      currentStatusGroup = {
        user_id: currentUser.id,
        username: "You",
        profile_image: currentUser.profile_image,
        statuses: statusData_My,
        isMe: true
      };
      currentViewerGroupIdx = -1; // Special index
      currentViewerItemIdx = 0;

      document.getElementById('statusViewer').style.display = 'flex';
      setupViewerListeners();
      showStatusItem();
    }

    function setupViewerListeners() {
      const area = document.getElementById('statusContentArea');
      area.onpointerdown = handleStatusDown;
      area.onpointerup = handleStatusUp;
      area.oncontextmenu = (e) => { e.preventDefault(); return false; };
    }

    async function deleteStatus(statusId) {
      if (!confirm("Delete this status update?")) return;
      try {
        await api(`/api/status/${statusId}`, { method: 'DELETE' });
        closeStatusViewer();
        loadStatuses();
        // alert("Status deleted");
      } catch (e) {
        alert("Delete failed: " + e.message);
      }
    }

    function getVideoDuration(file) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.onloadedmetadata = function () {
          window.URL.revokeObjectURL(video.src);
          resolve(video.duration);
        }
        video.onerror = function () { reject("Invalid video"); }
        video.src = URL.createObjectURL(file);
      });
    }

    let statusData_Friends = [];
    let statusData_My = []; // Array of status objects

    async function loadStatuses() {
      try {
        const data = await api('/api/status');
        statusData_My = data.my_status || [];
        statusData_Friends = data.friends_status || [];

        // Update My Status UI
        const myImg = document.getElementById('myStatusImg');
        const myStatusItem = document.querySelector('.status-item'); // Assuming first one is "My Status"

        if (myStatusItem) {
          if (statusData_My.length > 0) {
            if (currentUser && currentUser.profile_image) myImg.src = currentUser.profile_image;

            // Main click -> Open Viewer
            myStatusItem.onclick = () => openMyStatusViewer();

            // Clean up any existing buttons first (Fixes Double Plus Glitch)
            myStatusItem.querySelectorAll('.status-add-btn-overlay').forEach(el => el.remove());

            // Add (+) Button if not exists
            let plusBtn = document.createElement('div');
            plusBtn.className = 'status-add-btn-overlay';
            plusBtn.style.position = 'absolute';
            plusBtn.style.bottom = '5px';
            plusBtn.style.right = '5px';
            plusBtn.style.width = '20px';
            plusBtn.style.height = '20px';
            plusBtn.style.background = '#22c55e';
            plusBtn.style.borderRadius = '50%';
            plusBtn.style.display = 'flex';
            plusBtn.style.alignItems = 'center';
            plusBtn.style.justifyContent = 'center';
            plusBtn.style.color = 'white';
            plusBtn.style.fontSize = '14px';
            plusBtn.style.fontWeight = 'bold';
            plusBtn.innerHTML = '+';
            plusBtn.style.border = '2px solid var(--glass-panel-bg)';

            // Search for ring container to append to
            const ring = myStatusItem.querySelector('.status-ring');
            if (ring) ring.style.position = 'relative';
            if (ring) ring.appendChild(plusBtn);

            // Click handler
            plusBtn.onclick = (e) => {
              e.stopPropagation();
              triggerStatusUpload();
            };
          } else {
            if (currentUser && currentUser.profile_image) myImg.src = currentUser.profile_image;
            // No status -> Main click uploads
            myStatusItem.onclick = () => triggerStatusUpload();
            // Remove plus btn if exists
            const plusBtn = myStatusItem.querySelector('.status-add-btn-overlay');
            if (plusBtn) plusBtn.remove();
          }
        }

        // Render Friends List
        const list = document.getElementById('statusList');
        list.innerHTML = '';

        if (statusData_Friends.length === 0) {
          list.innerHTML = '<div style="padding:20px; text-align:center; color:gray;">No recent updates</div>';
        }

        statusData_Friends.forEach((fGroup, idx) => {
          const item = document.createElement('div');
          item.className = 'status-item';
          const isUnread = true;

          item.innerHTML = `
                   <div class="status-ring ${isUnread ? 'unread' : ''}">
                      <img src="${avatar(fGroup.profile_image, fGroup.username)}">
                   </div>
                   <div>
                      <div style="font-weight:600;">${fGroup.username}</div>
                      <div style="font-size:0.8rem; color:var(--text-muted);">${new Date(fGroup.last_update).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                   </div>
                `;
          item.onclick = () => openStatusViewer(idx);
          list.appendChild(item);
        });

      } catch (e) { console.error("Load status error", e); }
    }

    // Status Viewer Logic
    let currentViewerGroupIdx = -1;
    let currentViewerItemIdx = 0;
    let statusTimer = null;
    let currentStatusGroup = null; // { user_id, username, statuses: [] }
    let statusStartTime = 0;
    let isPaused = false;
    let remainingTime = 0;
    let currentDuration = 5000;

    function openStatusViewer(groupIdx) {
      currentViewerGroupIdx = groupIdx;
      currentStatusGroup = statusData_Friends[groupIdx];
      currentViewerItemIdx = 0;

      if (!currentStatusGroup || !currentStatusGroup.statuses.length) return;

      const viewer = document.getElementById('statusViewer');
      viewer.style.display = 'flex';

      // Setup interaction listeners
      const area = document.getElementById('statusContentArea');
      // Remove old listeners to be safe (though usually overwritten)
      area.onpointerdown = handleStatusDown;
      area.onpointerup = handleStatusUp;
      // Prevent context menu on long press
      area.oncontextmenu = (e) => { e.preventDefault(); return false; };

      showStatusItem();
    }

    function closeStatusViewer() {
      document.getElementById('statusViewer').style.display = 'none';
      clearTimeout(statusTimer);
      const vid = document.querySelector('#statusContentArea video');
      if (vid) vid.pause();
      isPaused = false;
    }

    function showStatusItem() {
      clearTimeout(statusTimer);
      const content = document.getElementById('statusContentArea');
      content.innerHTML = '';

      // Check Bounds
      if (currentViewerItemIdx < 0) {
        // Go to previous user
        if (currentViewerGroupIdx > 0) {
          currentViewerGroupIdx--;
          currentStatusGroup = statusData_Friends[currentViewerGroupIdx];
          currentViewerItemIdx = currentStatusGroup.statuses.length - 1;
          showStatusItem();
        } else {
          closeStatusViewer();
        }
        return;
      }

      if (currentViewerItemIdx >= currentStatusGroup.statuses.length) {
        // End of this user's statuses -> Next user
        if (currentViewerGroupIdx + 1 < statusData_Friends.length) {
          currentViewerGroupIdx++;
          currentStatusGroup = statusData_Friends[currentViewerGroupIdx];
          currentViewerItemIdx = 0;
          showStatusItem();
        } else {
          closeStatusViewer();
        }
        return;
      }

      const status = currentStatusGroup.statuses[currentViewerItemIdx];

      // Header Info
      document.getElementById('statusViewName').textContent = currentStatusGroup.username;
      document.getElementById('statusViewDp').src = avatar(currentStatusGroup.profile_image, currentStatusGroup.username);
      document.getElementById('statusViewTime').textContent = new Date(status.created_at).toLocaleString();

      // Render Progress Bars
      const progressContainer = document.getElementById('statusProgressContainer');
      progressContainer.innerHTML = '';
      currentStatusGroup.statuses.forEach((_, i) => {
        const bar = document.createElement('div');
        bar.className = 'status-progress-bar';
        const fill = document.createElement('div');
        fill.className = 'status-progress-fill';

        if (i < currentViewerItemIdx) fill.style.width = '100%';
        else if (i === currentViewerItemIdx) fill.style.width = '0%';
        else fill.style.width = '0%';

        bar.appendChild(fill);
        progressContainer.appendChild(bar);
      });

      // Update Like UI
      updateLikeUI(status.likes_count, status.is_liked);

      // Update Delete UI
      const delBtn = document.getElementById('statusDeleteBtnContainer');
      // Logic: if currentStatusGroup is Me, then I can delete.
      // But status object doesn't have user_id on it easily if group matches.
      // Better check: does currentStatusGroup.user_id === currentUser.id?
      if (currentStatusGroup.user_id === currentUser.id) {
        delBtn.classList.remove('hidden');
      } else {
        delBtn.classList.add('hidden');
      }

      // Content
      currentDuration = 5000; // Default

      if (status.type === 'text') {
        content.innerHTML = `<div class="status-text-view">${status.content}</div>`;
      } else if (status.type === 'image') {
        content.innerHTML = `<img src="${status.content}">`;
      } else if (status.type === 'video') {
        const vid = document.createElement('video');
        vid.src = status.content;
        vid.autoplay = true;
        vid.playsInline = true;
        // vid.muted = false; // Policies might block audio autoplay
        vid.onloadedmetadata = () => {
          currentDuration = vid.duration * 1000;
          if (!isPaused) startProgress(currentDuration);
        };
        vid.onended = () => navigateStatus(1);
        content.appendChild(vid);
        return; // Wait for metadata
      }

      if (!isPaused) startProgress(currentDuration);
    }

    function startProgress(duration) {
      statusStartTime = Date.now();
      remainingTime = duration;

      const bars = document.getElementsByClassName('status-progress-fill');
      if (bars[currentViewerItemIdx]) {
        bars[currentViewerItemIdx].style.transition = `width ${duration}ms linear`;
        // Trigger reflow
        setTimeout(() => {
          if (!isPaused) bars[currentViewerItemIdx].style.width = '100%';
        }, 50);
      }
      statusTimer = setTimeout(() => navigateStatus(1), duration);
    }

    function navigateStatus(dir) {
      currentViewerItemIdx += dir;
      showStatusItem();
    }

    // Interaction Logic
    let holdTimer;
    let holdStartTs;

    function handleStatusDown(e) {
      isPaused = true;
      holdStartTs = Date.now();

      // Pause Timer
      clearTimeout(statusTimer);

      // Calculate remaining time
      const elapsed = Date.now() - statusStartTime;
      remainingTime = Math.max(0, currentDuration - elapsed);

      // Pause Animation
      const bars = document.getElementsByClassName('status-progress-fill');
      if (bars[currentViewerItemIdx]) {
        const computedStyle = window.getComputedStyle(bars[currentViewerItemIdx]);
        const width = computedStyle.width;
        bars[currentViewerItemIdx].style.transition = 'none';
        bars[currentViewerItemIdx].style.width = width;
      }

      // Pause Video if active
      const vid = document.querySelector('#statusContentArea video');
      if (vid) vid.pause();
    }

    function handleStatusUp(e) {
      const holdDuration = Date.now() - holdStartTs;
      isPaused = false;

      // If held less than 200ms, treat as Tap
      if (holdDuration < 200) {
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        // Left 30% -> Prev, Right 70% -> Next
        if (x < rect.width * 0.3) {
          navigateStatus(-1);
        } else {
          navigateStatus(1);
        }
      } else {
        // Resume
        const bars = document.getElementsByClassName('status-progress-fill');
        if (bars[currentViewerItemIdx]) {
          bars[currentViewerItemIdx].style.transition = `width ${remainingTime}ms linear`;
          setTimeout(() => {
            bars[currentViewerItemIdx].style.width = '100%';
          }, 50);
        }

        statusTimer = setTimeout(() => navigateStatus(1), remainingTime);
        statusStartTime = Date.now(); // Reset start time for accurate subsequent pause
        currentDuration = remainingTime; // Update duration base

        const vid = document.querySelector('#statusContentArea video');
        if (vid) vid.play();
      }
    }
    function showAddFriend() {
      document.getElementById('addFriendModal').classList.remove('hidden');
    }
    function hideAddFriend() {
      document.getElementById('addFriendModal').classList.add('hidden');
    }

    async function deleteCurrentChat() {
      if (!currentChatId || currentChatType !== 'private') return;
      if (!confirm("Delete this chat permanently?")) return;
      try {
        await api(`/chat/delete/${currentChatId}`, { method: 'DELETE' });

        document.getElementById('welcomeScreen').classList.remove('hidden'); // Show welcome
        chatArea.classList.add('hidden');

        currentChatId = null;
        currentChatType = null;
        loadChats();
        alert("Chat deleted");
      } catch (e) {
        alert("Delete failed: " + e.message);
      }
    }

    async function sendFriendRequest() {
      const username = document.getElementById('friendUsername').value;
      try {
        await api('/friend-requests/send', { method: 'POST', body: JSON.stringify({ username }) });
        alert('Friend request sent!');
        hideAddFriend();
        loadChats();
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }

    // Messaging
    let searchTimeout = null;
    async function searchUsers(query) {
      const resultsDiv = document.getElementById('searchResults');
      if (!query || query.length < 1) {
        resultsDiv.style.display = 'none';
        return;
      }

      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(async () => {
        try {
          const results = await api(`/users/search?q=${encodeURIComponent(query)}`);
          resultsDiv.innerHTML = '';
          if (results.length > 0) {
            resultsDiv.style.display = 'block';
            results.forEach(user => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.innerHTML = `
                            <img src="${avatar(user.profile_image, user.username)}">
                            <span>${user.username}</span>
                        `;
              div.onclick = () => {
                document.getElementById('friendUsername').value = user.username;
                resultsDiv.style.display = 'none';
              };
              resultsDiv.appendChild(div);
            });
          } else {
            resultsDiv.style.display = 'none';
          }
        } catch (e) {
          console.error("Search error", e);
        }
      }, 300); // 300ms debounce
    }

    async function uploadImage(input) {
      const file = input.files[0];
      if (!file) return;

      // 1. Optimistic UI
      const tempId = 'temp_' + Date.now();
      const reader = new FileReader();
      reader.onload = function (e) {
        const base64 = e.target.result;
        // Add optimistic message
        addMessageToUI({
          id: tempId,
          client_temp_id: tempId,
          sender_id: currentUser.id,
          sender_name: currentUser.username,
          sender_dp: currentUser.profile_image,
          image_url: base64, // Display local base64
          timestamp: new Date().toISOString(),
          reactions: {},
          pending: true
        });
      };
      reader.readAsDataURL(file);

      const formData = new FormData();
      formData.append('image', file);
      const token = localStorage.getItem('token');
      try {
        const res = await fetch(API_BASE + '/upload-image', {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
          body: formData
        });
        const data = await res.json();

        if (!res.ok) throw new Error(data.msg || "Server Error");

        // 2. Send Real Message
        if (socket && currentChatId) {
          if (currentChatType === 'private') {
            socket.emit('send_message', {
              conversation_id: currentChatId,
              image_url: data.url,
              lifespan: document.getElementById('msgTimer').value || null,
              client_temp_id: tempId
            });
          } else if (currentChatType === 'group') {
            socket.emit('send_message', {
              group_id: currentChatId,
              image_url: data.url,
              lifespan: document.getElementById('msgTimer').value || null,
              client_temp_id: tempId
            });
          }
        }
      } catch (e) {
        alert('Image upload failed: ' + e.message);
        // Remove optimistic message if failed
        const failDiv = document.getElementById(`msg-${tempId}`);
        if (failDiv) failDiv.remove();
      }
    }



    function addMessageToUI(msg) {
      // STRICT FILTERING: Only show message if it belongs to current open chat
      if (msg.conversation_id) {
        if (currentChatType !== 'private' || currentChatId != msg.conversation_id) return;
      } else if (msg.group_id) {
        if (currentChatType !== 'group' || currentChatId != msg.group_id) return;
      } else {
        // Unknown message type?
        return;
      }

      // Handle Optimistic Replacement
      if (msg.client_temp_id) {
        const tempEl = document.getElementById(`msg-${msg.client_temp_id}`);
        if (tempEl) {
          tempEl.remove(); // Remove temporary, replace with finalized
        }
      }

      // Check duplicates (real ID)
      if (document.getElementById(`msg-${msg.id}`)) return;

      const div = document.createElement('div');
      const isMe = msg.sender_id === currentUser.id;

      // Add ID to div for replacement logic
      const elementId = msg.pending ? `msg-${msg.id}` : `msg-${msg.id}`;
      div.id = elementId;
      div.dataset.senderId = msg.sender_id;

      div.className = `message ${isMe ? 'user' : 'other'} ${msg.pending ? 'pending' : ''}`;

      // Avatar (Contextual if available) - ONLY show in Groups for others
      const dpUrl = msg.sender_dp;
      let contentHtml = '';

      if (currentChatType === 'group' && !isMe) {
        // In Group: Show small avatar + Name
        contentHtml += `
            <div style="display:flex; align-items:flex-start;">
                 <img src="${avatar(dpUrl, msg.sender_name)}" style="width:36px;height:36px;border-radius:50%;margin-right:8px;flex-shrink:0;">
                 <div>
                    <div class="sender-name">${msg.sender_name}</div>
                    ${msg.content ? `<div>${msg.content}</div>` : ''}
                    ${msg.image_url ? `<img src="${msg.image_url}" style="pointer-events:none;">` : ''}
                 </div>
            </div>
          `;
      } else {
        // Private Chat OR Me: Clean bubble
        contentHtml += `
            ${msg.content ? `<div>${msg.content}</div>` : ''}
            ${msg.image_url ? `<img src="${msg.image_url}" style="pointer-events:none;">` : ''}
          `;
      }

      // Seen Footer (Only for my messages)
      let seenHtml = '';
      if (isMe) {
        // Always show eye for my messages, clickable to see details
        // We don't show count here to keep it clean, or we can. User asked for "Eye"
        seenHtml = `<div class="seen-status clickable" onclick="event.stopPropagation(); showSeenDetails(${msg.id})">
              <span style="font-size:1.1rem;">üëÅ</span>
          </div>`;
      }

      const timeHtml = `<div class="msg-time">${formatTime(msg.timestamp)}</div>`;

      div.innerHTML = `
        ${contentHtml}
        ${timeHtml}
        <div class="reactions" id="reactions-${msg.id}"></div>
        <div class="seen-container" id="seen-${msg.id}"></div>
      `;

      // Append to DOM first
      messagesDiv.appendChild(div);

      // Add Seen Icon if Me
      if (isMe) {
        const seenContainer = document.getElementById(`seen-${msg.id}`);
        const eyeBtn = document.createElement('div');
        eyeBtn.className = 'seen-status clickable';
        eyeBtn.innerHTML = '<span style="font-size:1.1rem;">üëÅ</span>';
        eyeBtn.onclick = (e) => {
          e.stopPropagation(); // CRITICAL: Stop bubbling to message click
          console.log('Eye clicked', msg.id);
          showSeenDetails(msg.id);
        };
        seenContainer.appendChild(eyeBtn);
      }

      // Observe for read receipts - ONLY if it's NOT my message
      if (!isMe && !msg.pending) {
        seenObserver.observe(div);
      }

      updateReactionsUI(msg.id, msg.reactions);

      // On click (Single click) on the bubble itself
      div.onclick = (e) => {
        // Double check target is not reaction or eye (though stopPropagation should handle it)
        if (e.target.closest('.reaction') || e.target.closest('.seen-status')) return;
        showEmojiPicker(e, msg.id);
      };
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function updateSeenUI(messageId, username) {
      // Real-time update logic if needed
    }


    function sendMessage() {
      const content = messageInput.value.trim();
      const lifespan = document.getElementById('msgTimer').value || null;
      if (!content) return;

      if (socket && currentChatId) {
        const tempId = 'temp_' + Date.now();

        // 1. Optimistic UI
        addMessageToUI({
          id: tempId,
          client_temp_id: tempId,
          sender_id: currentUser.id,
          sender_name: currentUser.username,
          sender_dp: currentUser.profile_image,
          content: content,
          timestamp: new Date().toISOString(),
          reactions: {},
          pending: true
        });

        // 2. Emit
        const payload = { content, lifespan, client_temp_id: tempId };
        if (currentChatType === 'private') {
          payload.conversation_id = currentChatId;
        } else {
          payload.group_id = currentChatId;
        }
        socket.emit('send_message', payload);
        messageInput.value = '';
      }
    }

    function handleKeyPress(e) {
      if (e.key === 'Enter') sendMessage();
    }


    // MESSAGE RENDERING WITH REACTIONS
    function updateReactionsUI(messageId, reactions) {
      // console.log("updateReactionsUI called for msg:", messageId, reactions);
      const reactionsDiv = document.getElementById(`reactions-${messageId}`);
      if (!reactionsDiv) return;

      reactionsDiv.innerHTML = '';
      if (reactions && typeof reactions === 'object') {
        Object.entries(reactions).forEach(([emoji, count]) => {
          const span = document.createElement('span');
          span.className = 'reaction';
          span.textContent = `${emoji} ${count}`;
          span.style.cursor = 'pointer';
          span.onclick = (e) => {
            e.stopPropagation();
            showReactionDetails(messageId);
          };
          reactionsDiv.appendChild(span);
        });
      }
    }

    async function showReactionDetails(messageId) {
      try {
        const list = document.getElementById('reactionDetailsList');
        list.innerHTML = 'Loading...';
        document.getElementById('reactionDetailsModal').classList.remove('hidden');

        const reactions = await api(`/messages/${messageId}/reactions`);
        list.innerHTML = '';

        if (reactions.length === 0) {
          list.innerHTML = '<div style="padding:10px;text-align:center;color:#888">No reactions yet</div>';
          return;
        }

        reactions.forEach(r => {
          const div = document.createElement('div');
          div.className = 'chat-item';
          div.style.cursor = 'default';
          div.innerHTML = `
                   <img src="${avatar(r.profile_image, r.username)}" class="dp">
                   <div style="flex:1;">
                       <span style="font-weight:600;">${r.username}</span>
                   </div>
                   <span style="font-size:1.2rem;">${r.emoji}</span>
                `;
          list.appendChild(div);
        });
      } catch (e) {
        alert("Failed to load reactions: " + e.message);
      }
    }

    async function uploadDP(input) {
      const file = input.files[0];
      if (!file) return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      const res = await fetch(API_BASE + "/profile/upload-dp", {
        method: "POST",
        headers: { Authorization: `Bearer ${token}` },
        body: form
      });
      const data = await res.json();
      currentUser.profile_image = data.url;
      alert("Profile picture updated");
      loadChats();
    }

    async function uploadGroupIcon(input) {
      if (!currentChatId || currentChatType !== 'group') return;
      const file = input.files[0];
      if (!file) return;
      const form = new FormData();
      form.append("image", file);
      const token = localStorage.getItem("token");
      try {
        const res = await fetch(API_BASE + `/groups/${currentChatId}/upload-icon`, {
          method: "POST",
          headers: { Authorization: `Bearer ${token}` },
          body: form
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.msg || "Server Error");

        document.getElementById('chatDp').src = data.url;
        alert("Group Icon (Sigma) updated!");
        loadChats(); // refresh sidebar to show new icon
      } catch (e) {
        alert("Failed (" + e.message + ")");
      }
    }



    function showEmojiPicker(e, messageId) {
      console.log("showEmojiPicker called for msg:", messageId);
      e.stopPropagation(); // Stop bubbling
      e.preventDefault();

      const msgElement = e.currentTarget; // The message div

      emojiPicker.innerHTML = '';
      EMOJIS.forEach(emoji => {
        const span = document.createElement('span');
        span.className = 'emoji';
        span.textContent = emoji;
        span.onclick = (evt) => {
          evt.stopPropagation();
          console.log("Emoji selected:", emoji);
          if (socket) {
            console.log("Emitting react:", { message_id: messageId, emoji });

            // 1. Optimistic UI Update
            const reactionsDiv = document.getElementById(`reactions-${messageId}`);
            if (reactionsDiv) {
              // Check if I already reacted? Handling that optimistically is complex without local state.
              // Simplified: Just increment count or append emoji locally for visual feedback
              // We'll rely on server broadcast for perfect accuracy, but showing "..." or immediate update is good.
              // Let's just optimistic increment.
              let found = false;
              for (let child of reactionsDiv.children) {
                if (child.textContent.includes(emoji)) {
                  const parts = child.textContent.split(' ');
                  const count = parseInt(parts[1]) + 1;
                  child.textContent = `${emoji} ${count}`;
                  found = true;
                  break;
                }
              }
              if (!found) {
                const span = document.createElement('span');
                span.className = 'reaction';
                span.textContent = `${emoji} 1`;
                reactionsDiv.appendChild(span);
              }
            }

            socket.emit('react', { message_id: messageId, emoji });
          } else {
            console.error("Socket not connected!");
            alert("Connection error: please refresh");
          }
          emojiPicker.style.display = 'none'; // Close after select
        };
        emojiPicker.appendChild(span);
      });

      // SMART POSITIONING LOGIC
      const rect = msgElement.getBoundingClientRect();
      const pickerHeight = 200; // Approx height
      const pickerWidth = 250;  // Approx width

      let left = rect.left;
      let top = rect.bottom + 5; // Default: below message

      // Check vertical overflow (bottom)
      if (top + pickerHeight > window.innerHeight) {
        top = rect.top - pickerHeight - 5; // Position above if no space below
      }

      // Check horizontal overflow (right)
      if (left + pickerWidth > window.innerWidth) {
        left = window.innerWidth - pickerWidth - 10; // Shift left if off screen
      }

      // Ensure not off-top (if message is very high up and we moved picker above)
      if (top < 0) {
        top = 10; // Force sticky to top
      }

      emojiPicker.style.left = `${left}px`;
      emojiPicker.style.top = `${top}px`;
      emojiPicker.style.display = 'grid'; // Make visible

      // One-time click outside listener
      const closePicker = (evt) => {
        if (!emojiPicker.contains(evt.target)) {
          emojiPicker.style.display = 'none';
          document.removeEventListener('click', closePicker);
        }
      };
      setTimeout(() => document.addEventListener('click', closePicker), 0);
    }



    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Theme Logic
    function toggleTheme() {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      updateThemeBtn();
      // Static themes work on top of light/dark mode, or replace background
      // For now, static themes are just backgrounds for chat area.
    }

    function updateThemeBtn() {
      const btn = document.getElementById('themeToggleBtn');
      if (btn) {
        const isLight = document.body.classList.contains('light-mode');
        btn.textContent = isLight ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
        btn.style.background = isLight ? '#0f172a' : 'var(--primary-gradient)';
        btn.style.color = isLight ? 'white' : 'white';
      }
    }

    // Static Wallpaper Logic
    let currentWallpaper = 'default';

    function selectTheme(themeName) {
      currentWallpaper = themeName;
      localStorage.setItem('chatWallpaper', themeName);
      applyWallpaper();
      updateThemeSelectionUI();
    }

    function applyWallpaper() {
      const bg = document.getElementById('chat-background');
      if (!bg) return;

      // Reset classes
      bg.className = '';

      // Apply new class
      if (currentWallpaper !== 'default') {
        bg.classList.add(`theme-${currentWallpaper}`);
      }
    }

    function updateThemeSelectionUI() {
      document.querySelectorAll('.theme-option').forEach(el => {
        if (el.dataset.theme === currentWallpaper) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }

    function initTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'light') {
        document.body.classList.add('light-mode');
      }

      const savedWallpaper = localStorage.getItem('chatWallpaper');
      if (savedWallpaper) {
        currentWallpaper = savedWallpaper;
      }
      applyWallpaper();
    }

    // Initialize Theme immediately
    initTheme();

    /* ================= WebRTC Audio Call Logic ================= */
    let localStream;
    let screenStream;
    let peerConnection;
    let candidateQueue = []; // Queue for ICE candidates
    // let currentChatFriendId = null; // Defined globally above or implicitly

    // 1. Optimize Connection Speed
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10 // Pre-gather candidates
    };

    // 2. Improve Audio Quality
    const audioConstraints = {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: { ideal: true }
    };

    // UI Helpers
    function showCallOverlay(name, dp) {
      document.getElementById('callOverlay').classList.remove('hidden');
      document.getElementById('callName').textContent = name;
      document.getElementById('callAvatar').src = avatar(dp, name);
      document.getElementById('callStatus').textContent = "Calling...";
    }

    function hideCallOverlay() {
      document.getElementById('callOverlay').classList.add('hidden');
      stopRingtone();
    }

    function playRingtone() {
      // user interaction required usually, but usually works if triggered by event
      document.getElementById('ringtone').play().catch(e => console.log("Audio play error", e));
    }
    function stopRingtone() {
      document.getElementById('ringtone').pause();
      document.getElementById('ringtone').currentTime = 0;
    }

    async function startCall() {
      if (!currentChatId || currentChatType !== 'private') {
        alert("Can only call in private chats.");
        return;
      }

      // Determine friend details
      const friendName = chatHeader.querySelector('span > div > span').textContent;
      const friendDp = document.getElementById('chatDp').src;

      showCallOverlay(friendName, friendDp);
      document.getElementById('callStatus').textContent = "Accessing Microphone...";

      try {
        // Check for devices first
        const devices = await navigator.mediaDevices.enumerateDevices();
        const hasMic = devices.some(d => d.kind === 'audioinput');
        if (!hasMic) {
          throw new Error("No microphone found. Please connect a headset.");
        }

        localStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints }); // Use optimized constraints
        createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        document.getElementById('callStatus').textContent = "Calling...";
        const offer = await peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }); // Explicit offer
        await peerConnection.setLocalDescription(offer);

        socket.emit('call_user', {
          user_to_call: currentChatFriendId,
          signal_data: offer,
          from: currentUser.id
        });

      } catch (e) {
        console.error("Call Error:", e);
        let msg = e.message;
        if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
          msg = "Microphone permission denied. Please allow access in browser settings.";
        } else if (e.name === 'NotFoundError' || e.name === 'DevicesNotFoundError') {
          msg = "Microphone not found.";
        }
        alert("Call Failed: " + msg);
        endCall();
      }
    }

    // Global to store who we are talking to
    // let currentChatFriendId is set in openPrivateChat

    function setupCallSocketListeners() {
      if (!socket) return;

      socket.on('incoming_call', async (data) => {
        // Handle Renegotiation (Screen Share update)
        if (peerConnection && currentChatFriendId === data.from) {
          console.log("Renegotiation offer received");
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));
          // Process queued candidates now that we have remote description
          while (candidateQueue.length > 0) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
          }
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer_call', { signal: answer, to: data.from });
          return;
        }

        if (peerConnection) return; // Busy

        // Show Modal
        document.getElementById('incomingCallModal').classList.remove('hidden');
        document.getElementById('incomingCallerName').textContent = "Incoming Call...";

        // Fetch caller name
        try {
          const friends = await api('/friends');
          const friend = friends.find(f => f.id === data.from);
          if (friend) document.getElementById('incomingCallerName').textContent = friend.username;
        } catch (e) { }

        playRingtone();
        window.incomingCallData = data;
      });

      socket.on('call_accepted', async (data) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));
        // Process queued candidates
        while (candidateQueue.length > 0) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
        }
        document.getElementById('callStatus').textContent = "Connected";
      });

      socket.on('ice_candidate', async (data) => {
        if (!peerConnection) return;

        // Queue candidates if remote description isn't set yet
        if (!peerConnection.remoteDescription) {
          console.log("Queueing ICE candidate (RemoteDesc not set)");
          candidateQueue.push(data.candidate);
        } else {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });

      socket.on('incoming_call', async (data) => {
        // ... (existing logic)
        // Store extra data for UI use
        data.callerName = "Unknown";
        data.callerDp = null;

        try {
          const friends = await api('/friends');
          const friend = friends.find(f => f.id === data.from);
          if (friend) {
            data.callerName = friend.username;
            data.callerDp = friend.profile_image;
          }
        } catch (e) { }

        window.incomingCallData = data;
      });


      socket.on('call_ended', () => {
        // Clear everything
        endCall(false);
        document.getElementById('incomingCallModal').classList.add('hidden'); // Force hide
        stopRingtone();
        // alert("Call Ended"); // Optional: less spammy if we remove alert
      });

      socket.on('call_answered_elsewhere', () => {
        document.getElementById('incomingCallModal').classList.add('hidden');
        stopRingtone();
      });

      // 3. Fix Screen Share Cache
      socket.on('stop_screen_share', () => {
        console.log("Remote screen share stopped");
        const vid = document.getElementById('remoteVideo');
        vid.srcObject = null; // Clear stream
        vid.style.display = 'none'; // Hide element
      });
    }

    // Call Actions
    async function acceptCall() {
      document.getElementById('incomingCallModal').classList.add('hidden');
      stopRingtone();
      const data = window.incomingCallData;

      showCallOverlay(window.incomingCallData.callerName || "Connected", null);
      if (window.incomingCallData.callerName && window.incomingCallData.callerDp) {
        document.getElementById('callAvatar').src = avatar(window.incomingCallData.callerDp, window.incomingCallData.callerName);
      }
      document.getElementById('callStatus').textContent = "Connecting...";

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints }); // Use optimized constraints

        currentChatFriendId = data.from; // Set ID BEFORE creating PC to allow ICE candidates

        // FIX: Ensure conversation context is loaded for whiteboard sync & minimize visibility
        try {
          const convData = await api(`/conversation-with/${currentChatFriendId}`);
          currentChatId = convData.conversation_id;
          currentChatType = 'private'; // Calls are private only

          // Join socket room for WB events
          if (socket) socket.emit('join_private_chat', { conversation_id: currentChatId });

          // Optionally open chat in background? No, let minimize handle it if logical.
          // But setting currentChatId is CRITICAL for whiteboard.
        } catch (e) { console.error("Failed to load chat context for call:", e); }

        createPeerConnection();
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));

        // Process queued candidates
        while (candidateQueue.length > 0) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
        }

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit('answer_call', {
          signal: answer,
          to: data.from
        });

        document.getElementById('callStatus').textContent = "Connected";

      } catch (e) {
        console.error(e);
        endCall();
      }
    }

    function rejectCall() {
      document.getElementById('incomingCallModal').classList.add('hidden');
      stopRingtone();
      socket.emit('end_call', { to: window.incomingCallData.from });
    }

    function endCall(emitEvent = true) {
      hideCallOverlay();
      candidateQueue = []; // Clear queue

      // Stop Local Media
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      // Stop Screen Share if active (Fixes persisting UI and stream)
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
        // Reset UI button state
        const btn = document.querySelector('.btn-screen');
        if (btn) btn.style.background = 'rgba(255,255,255,0.2)';
      }

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      // Clear Remote Video (Fixes Black Box on Next Call)
      const vid = document.getElementById('remoteVideo');
      if (vid) {
        vid.pause();
        vid.removeAttribute('src');
        vid.removeAttribute('srcObject');
        vid.srcObject = null;
        vid.style.display = 'none';
      }

      // Cleanup Mini Widget
      document.getElementById('miniCallWidget').classList.add('hidden');
      document.getElementById('callOverlay').classList.add('hidden'); // Ensure closed

      if (emitEvent && currentChatFriendId) {
        socket.emit('end_call', { to: currentChatFriendId });
        // Also emit stop_screen_share just in case to clear remote side
        socket.emit('stop_screen_share', { to: currentChatFriendId });
      }
    }

    function toggleMute() {
      if (localStream) {
        const track = localStream.getAudioTracks()[0];
        track.enabled = !track.enabled;

        // Update UI
        const isMuted = !track.enabled;
        const mainBtn = document.getElementById('mainMuteBtn');
        const miniBtn = document.getElementById('miniMuteBtn');

        if (isMuted) {
          if (mainBtn) {
            mainBtn.style.background = '#ef4444';
            mainBtn.textContent = 'üîá';
          }
          if (miniBtn) {
            miniBtn.style.background = '#ef4444';
            miniBtn.textContent = 'üîá';
          }
        } else {
          if (mainBtn) {
            mainBtn.style.background = 'rgba(255,255,255,0.2)';
            mainBtn.textContent = 'üé§';
          }
          if (miniBtn) {
            miniBtn.style.background = 'rgba(255,255,255,0.1)';
            miniBtn.textContent = 'üé§';
          }
        }
      }
    }

    // Minimize/Maximize Call
    function minimizeCall() {
      const overlay = document.getElementById('callOverlay');
      const miniWidget = document.getElementById('miniCallWidget');
      const miniStatus = document.getElementById('miniCallStatus');

      overlay.classList.add('hidden');
      miniWidget.classList.remove('hidden');

      // Determine name logic
      let name = "Unknown";

      const callNameEl = document.getElementById('callName');
      const overlayName = callNameEl ? callNameEl.textContent : "";

      if (currentChatName) {
        name = currentChatName;
      } else if (overlayName && overlayName !== "Unknown" && overlayName !== "Connected" && overlayName !== "Calling...") {
        name = overlayName;
      } else if (window.incomingCallData && window.incomingCallData.callerName) {
        name = window.incomingCallData.callerName;
      } else if (overlayName) {
        name = overlayName; // Fallback to "Connected" or whatever
      } else if (window.incomingCallData && window.incomingCallData.from) {
        name = "User " + window.incomingCallData.from;
      }

      miniStatus.textContent = `On call with ${name}`;
    }

    function maximizeCall() {
      document.getElementById('callOverlay').classList.remove('hidden');
      document.getElementById('miniCallWidget').classList.add('hidden');
    }

    async function startScreenShare() {
      if (!peerConnection) {
        alert("You must be in a call to share screen.");
        return;
      }
      try {
        // OPTIMIZATION: Limit resolution and frame rate to reduce lag
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            cursor: "always",
            width: { max: 1280, ideal: 1280 },
            height: { max: 720, ideal: 720 },
            frameRate: { max: 15 } // Lower frame rate for smoother presentation
          },
          audio: false
        });
        const videoTrack = screenStream.getVideoTracks()[0];

        // Add to PC
        const sender = peerConnection.addTrack(videoTrack, localStream);

        // Handle Stop via browser UI
        videoTrack.onended = () => {
          stopScreenShare(sender);
        };

        // Negotiate
        forceRenegotiation();

        // UI update
        document.querySelector('.btn-screen').style.background = '#22c55e'; // Green

      } catch (e) {
        console.error("Screen Share Error", e);
        alert("Detailed error: " + e.message);
      }
    }

    function stopScreenShare(sender) {
      if (sender) {
        try { peerConnection.removeTrack(sender); } catch (e) { }
      }
      if (screenStream) {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }

      // Explicit Stop Signal
      if (socket && currentChatFriendId) {
        socket.emit('stop_screen_share', { to: currentChatFriendId });
      }

      // FORCE CLEAR VIDEO BUFFER (Fixes frozen frame)
      const vid = document.getElementById('remoteVideo');
      vid.pause();
      vid.removeAttribute('src'); // Remove src attribute
      vid.removeAttribute('srcObject'); // Remove srcObject
      vid.srcObject = null;
      vid.src = "";
      vid.load(); // Force reload to clear buffer
      vid.style.display = 'none';

      forceRenegotiation();
      document.querySelector('.btn-screen').style.background = 'rgba(255,255,255,0.2)';
    }

    async function forceRenegotiation() {
      try {
        const offer = await peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }); // Ensure audio offer persists
        await peerConnection.setLocalDescription(offer);
        socket.emit('call_user', {
          user_to_call: currentChatFriendId,
          signal_data: offer,
          from: currentUser.id
        });
      } catch (e) { console.error("Renegotiation failed", e); }
    }

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(rtcConfig);
      candidateQueue = []; // Reset queue for new connection

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && currentChatFriendId) {
          socket.emit('ice_candidate', {
            to: currentChatFriendId,
            candidate: event.candidate
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log("Connection State:", peerConnection.connectionState);
        const status = document.getElementById('callStatus');
        if (peerConnection.connectionState === 'connected') {
          status.textContent = "Connected (SECURE)";
          status.style.color = "#4ade80"; // Green
        } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
          status.textContent = "Reconnecting...";
          status.style.color = "#facc15"; // Yellow
        } else if (peerConnection.connectionState === 'closed') {
          status.textContent = "Call Ended";
        }
      };

      peerConnection.ontrack = (event) => {
        const stream = event.streams[0];
        if (event.track.kind === 'video') {
          console.log("Remote Video Track Received");
          const vid = document.getElementById('remoteVideo');
          vid.srcObject = stream;
          vid.style.display = 'block';
          vid.muted = true; // Mute video element to avoid audio echo (audio handled by remoteAudio)
          vid.play().catch(e => console.error("Video play failed", e));
        } else {
          console.log("Remote Audio Track Received");
          const aud = document.getElementById('remoteAudio');
          aud.srcObject = stream;
          aud.volume = 1.0; // Ensure max volume
          aud.muted = false; // Explicitly unmute

          // Try to play
          const playPromise = aud.play();
          if (playPromise !== undefined) {
            playPromise.then(_ => {
              console.log("Audio playing successfully");
            }).catch(e => {
              console.error("Audio play failed (Autoplay blocked?):", e);
              // Show helper UI
              document.getElementById('audioHelper').classList.remove('hidden');
            });
          }
        }
      };
    }

    // Legacy Whiteboard Logic Removed





    /* ================= Notepad Logic ================= */
    let currentNoteId = null;

    function showNotepadDashboard() {
      document.getElementById('sidebar').classList.add('hidden');
      // Inline style cleanup handled by class
      // document.querySelector('.sidebar').style.display = 'none'; 
      // document.querySelector('.main-chat').style.display = 'none';
      chatArea.classList.add('hidden');
      document.getElementById('welcomeScreen').classList.add('hidden');
      document.getElementById('whiteboardDashboard').classList.add('hidden');
      document.getElementById('notepadDashboard').classList.remove('hidden');
      loadNotepads();
    }

    async function loadNotepads() {
      const grid = document.getElementById('notepadGrid');
      grid.innerHTML = '<p>Loading...</p>';
      try {
        const notes = await api('/api/notepads');
        grid.innerHTML = '';
        if (notes.length === 0) {
          grid.innerHTML = '<p>No notes yet. Create one!</p>';
          return;
        }
        notes.forEach(n => {
          const card = document.createElement('div');
          card.className = 'wb-card'; // Reuse WB card style
          card.innerHTML = `
                    <div class="wb-thumbnail" style="font-size:3rem; display:flex; align-items:center; justify-content:center;">üìù</div>
                    <div class="wb-title">${n.name}</div>
                    <div class="wb-date">${new Date(n.updated_at).toLocaleDateString()}</div>
                    <button onclick="deleteNotepad(event, ${n.id})" style="position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:white; border-radius:50%; width:24px; height:24px; display:flex; 
                    align-items:center; justify-content:center; border:none;">‚úï</button>
                `;
          card.onclick = (e) => {
            if (e.target.tagName === 'BUTTON') return;
            openNotepad(n.id);
          };
          grid.appendChild(card);
        });
      } catch (e) {
        grid.innerHTML = '<p style="color:red">Failed to load notepads</p>';
      }
    }

    async function createNotepad() {
      try {
        const res = await api('/api/notepads', {
          method: 'POST',
          body: JSON.stringify({ name: "Untitled Note" })
        });
        openNotepad(res.id);
      } catch (e) {
        alert("Error creating note: " + e.message);
      }
    }

    async function openNotepad(id) {
      try {
        const data = await api(`/api/notepads/${id}`);
        currentNoteId = data.id;
        document.getElementById('noteTitle').value = data.name;
        document.getElementById('noteContent').value = data.content || '';
        document.getElementById('notepadDashboard').classList.add('hidden');

        const ui = document.getElementById('notepadUI');
        ui.classList.remove('hidden');
        ui.style.display = 'flex'; // Ensure flex layout
      } catch (e) {
        alert("Failed to open note: " + e.message);
      }
    }

    async function saveNotepad() {
      if (!currentNoteId) return;
      const name = document.getElementById('noteTitle').value;
      const content = document.getElementById('noteContent').value;
      document.getElementById('noteSaveStatus').textContent = "Saving...";

      try {
        await api(`/api/notepads/${currentNoteId}`, {
          method: 'POST',
          body: JSON.stringify({ name, content })
        });
        document.getElementById('noteSaveStatus').textContent = "Saved";
        setTimeout(() => {
          document.getElementById('noteSaveStatus').textContent = "";
        }, 2000);
      } catch (e) {
        document.getElementById('noteSaveStatus').textContent = "Error";
        alert("Save failed: " + e.message);
      }
    }

    async function deleteNotepad(e, id) {
      e.stopPropagation();
      if (!confirm("Delete this note?")) return;
      try {
        await api(`/api/notepads/${id}`, { method: 'DELETE' });
        loadNotepads();
      } catch (e) {
        alert("Failed to delete");
      }
    }

    function closeNotepadUI() {
      document.getElementById('notepadUI').classList.add('hidden');
      document.getElementById('notepadUI').style.display = 'none';
      currentNoteId = null;
      showNotepadDashboard();
    }

    // Auto-save on typing (debounce)
    let noteTimeout;
    document.getElementById('noteContent').addEventListener('input', () => {
      document.getElementById('noteSaveStatus').textContent = "Unsaved...";
      clearTimeout(noteTimeout);
      noteTimeout = setTimeout(saveNotepad, 2000);
    });
    document.getElementById('noteTitle').addEventListener('input', () => {
      document.getElementById('noteSaveStatus').textContent = "Unsaved...";
      clearTimeout(noteTimeout);
      noteTimeout = setTimeout(saveNotepad, 2000);
    });

    // App Initialization
    if (localStorage.getItem('token')) {
      initApp();
    }
  </script>
  <script>

    // --- State & Constants ---
    const SHAPES = {
      'rect': { name: 'Rectangle', icon: '‚¨ú', path: (ctx, x, y, w, h) => ctx.rect(x, y, w, h) },
      'circle': { name: 'Circle', icon: '‚ö™', path: (ctx, x, y, w, h) => { ctx.arc(x + w / 2, y + h / 2, Math.abs(w) / 2, 0, 2 * Math.PI); } },
      'triangle': {
        name: 'Triangle', icon: 'üî∫', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w / 2, y); ctx.lineTo(x, y + h); ctx.lineTo(x + w, y + h); ctx.closePath();
        }
      },
      'star': {
        name: 'Star', icon: '‚≠ê', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, outer = Math.abs(w) / 2, inner = outer / 2;
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer);
            ctx.lineTo(cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner);
          }
          ctx.closePath();
        }
      },
      'arrow_r': {
        name: 'Arrow Right', icon: '‚û°Ô∏è', path: (ctx, x, y, w, h) => {
          const my = y + h / 2;
          ctx.moveTo(x, my - h / 4); ctx.lineTo(x + w * 0.7, my - h / 4); ctx.lineTo(x + w * 0.7, y);
          ctx.lineTo(x + w, my); ctx.lineTo(x + w * 0.7, y + h); ctx.lineTo(x + w * 0.7, my + h / 4);
          ctx.lineTo(x, my + h / 4); ctx.closePath();
        }
      },
      'arrow_l': {
        name: 'Arrow Left', icon: '‚¨ÖÔ∏è', path: (ctx, x, y, w, h) => {
          const my = y + h / 2;
          ctx.moveTo(x + w, my - h / 4); ctx.lineTo(x + w * 0.3, my - h / 4); ctx.lineTo(x + w * 0.3, y);
          ctx.lineTo(x, my); ctx.lineTo(x + w * 0.3, y + h); ctx.lineTo(x + w * 0.3, my + h / 4);
          ctx.lineTo(x + w, my + h / 4); ctx.closePath();
        }
      },
      'arrow_u': {
        name: 'Arrow Up', icon: '‚¨ÜÔ∏è', path: (ctx, x, y, w, h) => {
          const mx = x + w / 2;
          ctx.moveTo(mx - w / 4, y + h); ctx.lineTo(mx - w / 4, y + h * 0.3); ctx.lineTo(x, y + h * 0.3);
          ctx.lineTo(mx, y); ctx.lineTo(x + w, y + h * 0.3); ctx.lineTo(mx + w / 4, y + h * 0.3);
          ctx.lineTo(mx + w / 4, y + h); ctx.closePath();
        }
      },
      'arrow_d': {
        name: 'Arrow Down', icon: '‚¨áÔ∏è', path: (ctx, x, y, w, h) => {
          const mx = x + w / 2;
          ctx.moveTo(mx - w / 4, y); ctx.lineTo(mx - w / 4, y + h * 0.7); ctx.lineTo(x, y + h * 0.7);
          ctx.lineTo(mx, y + h); ctx.lineTo(x + w, y + h * 0.7); ctx.lineTo(mx + w / 4, y + h * 0.7);
          ctx.lineTo(mx + w / 4, y); ctx.closePath();
        }
      },
      'diamond': {
        name: 'Diamond', icon: 'üî∂', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w / 2, y); ctx.lineTo(x + w, y + h / 2); ctx.lineTo(x + w / 2, y + h); ctx.lineTo(x, y + h / 2); ctx.closePath();
        }
      },
      'cloud': {
        name: 'Cloud', icon: '‚òÅÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w * 0.2, y + h * 0.7, w * 0.2, 0, 2 * Math.PI);
          ctx.arc(x + w * 0.5, y + h * 0.6, w * 0.3, 0, 2 * Math.PI);
          ctx.arc(x + w * 0.8, y + h * 0.7, w * 0.2, 0, 2 * Math.PI);
        }
      },
      'heart': {
        name: 'Heart', icon: '‚ù§Ô∏è', path: (ctx, x, y, w, h) => {
          const topCurveHeight = h * 0.3;
          ctx.moveTo(x + w / 2, y + h * 0.2);
          ctx.bezierCurveTo(x + w / 2, y, x, y, x, y + topCurveHeight);
          ctx.bezierCurveTo(x, y + (h + topCurveHeight) / 2, x + w / 2, y + h, x + w / 2, y + h);
          ctx.bezierCurveTo(x + w / 2, y + h, x + w, y + (h + topCurveHeight) / 2, x + w, y + topCurveHeight);
          ctx.bezierCurveTo(x + w, y, x + w / 2, y, x + w / 2, y + h * 0.2);
          ctx.closePath();
        }
      },
      'check': {
        name: 'Check', icon: '‚úîÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x, y + h * 0.5); ctx.lineTo(x + w * 0.4, y + h); ctx.lineTo(x + w, y);
        }
      },
      'cross': {
        name: 'Cross', icon: '‚ùå', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x, y); ctx.lineTo(x + w, y + h);
          ctx.moveTo(x + w, y); ctx.lineTo(x, y + h);
        }
      },
      'thought': {
        name: 'Thought', icon: 'üí≠', path: (ctx, x, y, w, h) => {
          ctx.ellipse(x + w * 0.5, y + h * 0.4, w * 0.4, h * 0.3, 0, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.3, y + h * 0.7); ctx.arc(x + w * 0.2, y + h * 0.8, w * 0.05, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.15, y + h * 0.9); ctx.arc(x + w * 0.1, y + h * 0.95, w * 0.03, 0, 2 * Math.PI);
        }
      },
      'cube': {
        name: 'Cube', icon: 'üßä', path: (ctx, x, y, w, h) => {
          const d = w * 0.25;
          ctx.rect(x, y + d, w - d, h - d);
          ctx.moveTo(x, y + d); ctx.lineTo(x + d, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w - d, y + d);
          ctx.moveTo(x + w, y); ctx.lineTo(x + w, y + h - d); ctx.lineTo(x + w - d, y + h);
        }
      },
      'cylinder': {
        name: 'Cylinder', icon: 'üõ¢Ô∏è', path: (ctx, x, y, w, h) => {
          const eh = h * 0.15;
          ctx.ellipse(x + w / 2, y + eh, w / 2, eh, 0, 0, 2 * Math.PI);
          ctx.moveTo(x, y + eh); ctx.lineTo(x, y + h - eh);
          ctx.ellipse(x + w / 2, y + h - eh, w / 2, eh, 0, 0, Math.PI); // Bottom half
          ctx.lineTo(x + w, y + eh);
        }
      },
      'smiley': {
        name: 'Smile', icon: 'üôÇ', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI); // Face
          ctx.moveTo(x + w * 0.3, y + h * 0.4); ctx.arc(x + w * 0.3, y + h * 0.4, w * 0.05, 0, 2 * Math.PI); // Eye L
          ctx.moveTo(x + w * 0.7, y + h * 0.4); ctx.arc(x + w * 0.7, y + h * 0.4, w * 0.05, 0, 2 * Math.PI); // Eye R
          ctx.moveTo(x + w * 0.2, y + h * 0.6); ctx.bezierCurveTo(x + w * 0.2, y + h * 0.9, x + w * 0.8, y + h * 0.9, x + w * 0.8, y + h * 0.6);
        }
      },
      'parallelogram': {
        name: 'Parallelogram', icon: '‚ñ∞', path: (ctx, x, y, w, h) => {
          const skew = w * 0.2;
          ctx.moveTo(x + skew, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w - skew, y + h); ctx.lineTo(x, y + h); ctx.closePath();
        }
      },
      'trapezoid': {
        name: 'Trapezoid', icon: '‚è¢', path: (ctx, x, y, w, h) => {
          const inset = w * 0.2;
          ctx.moveTo(x + inset, y); ctx.lineTo(x + w - inset, y); ctx.lineTo(x + w, y + h); ctx.lineTo(x, y + h); ctx.closePath();
        }
      },
      'hexagon': {
        name: 'Hexagon', icon: '‚¨°', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = Math.min(w, h) / 2;
          for (let i = 0; i < 6; i++) {
            ctx.lineTo(cx + r * Math.cos(i * 2 * Math.PI / 6), cy + r * Math.sin(i * 2 * Math.PI / 6));
          }
          ctx.closePath();
        }
      },
      'pentagon': {
        name: 'Pentagon', icon: '‚¨†', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = Math.min(w, h) / 2;
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(cx + r * Math.cos(i * 2 * Math.PI / 5 - Math.PI / 2), cy + r * Math.sin(i * 2 * Math.PI / 5 - Math.PI / 2));
          }
          ctx.closePath();
        }
      },
      'document': {
        name: 'Document', icon: 'üìÑ', path: (ctx, x, y, w, h) => {
          const fold = w * 0.3;
          ctx.moveTo(x, y); ctx.lineTo(x + w - fold, y); ctx.lineTo(x + w, y + fold); ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h); ctx.closePath();
          ctx.moveTo(x + w - fold, y); ctx.lineTo(x + w - fold, y + fold); ctx.lineTo(x + w, y + fold);
        }
      },
      'database': {
        name: 'Database', icon: 'üóÑÔ∏è', path: (ctx, x, y, w, h) => {
          const eh = h * 0.15;
          ctx.ellipse(x + w / 2, y + eh, w / 2, eh, 0, 0, 2 * Math.PI);
          ctx.moveTo(x, y + eh); ctx.lineTo(x, y + h - eh);
          ctx.ellipse(x + w / 2, y + h - eh, w / 2, eh, 0, 0, Math.PI);
          ctx.lineTo(x + w, y + eh);
          ctx.moveTo(x, y + h * 0.5); ctx.ellipse(x + w / 2, y + h * 0.5, w / 2, eh, 0, 0, Math.PI);
        }
      },
      'sun': {
        name: 'Sun', icon: '‚òÄÔ∏è', path: (ctx, x, y, w, h) => {
          const cx = x + w / 2, cy = y + h / 2, r = w * 0.25;
          ctx.arc(cx, cy, r, 0, 2 * Math.PI);
          for (let i = 0; i < 8; i++) {
            const angle = i * Math.PI / 4;
            ctx.moveTo(cx + Math.cos(angle) * r * 1.2, cy + Math.sin(angle) * r * 1.2);
            ctx.lineTo(cx + Math.cos(angle) * r * 1.8, cy + Math.sin(angle) * r * 1.8);
          }
        }
      },
      'moon': {
        name: 'Moon', icon: 'üåô', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w / 2, y + h / 2, w * 0.4, 0, 2 * Math.PI); // Base circle
          // Simplified clip? Canvas path clip is complex in one stroke.
          // Just draw a crescent using bezier
          ctx.moveTo(x + w * 0.5, y + h * 0.1);
          ctx.bezierCurveTo(x + w, y + h * 0.5, x + w * 0.5, y + h * 0.9, x + w * 0.5, y + h * 0.9);
          ctx.bezierCurveTo(x + w * 0.8, y + h * 0.5, x + w * 0.5, y + h * 0.1, x + w * 0.5, y + h * 0.1);
        }
      },
      'lightning': {
        name: 'Lightning', icon: '‚ö°', path: (ctx, x, y, w, h) => {
          ctx.moveTo(x + w * 0.6, y); ctx.lineTo(x + w * 0.3, y + h * 0.6); ctx.lineTo(x + w * 0.5, y + h * 0.6);
          ctx.lineTo(x + w * 0.4, y + h); ctx.lineTo(x + w * 0.7, y + h * 0.4); ctx.lineTo(x + w * 0.5, y + h * 0.4);
          ctx.closePath();
        }
      },
      'lock': {
        name: 'Lock', icon: 'üîí', path: (ctx, x, y, w, h) => {
          ctx.rect(x + w * 0.2, y + h * 0.4, w * 0.6, h * 0.6);
          ctx.moveTo(x + w * 0.3, y + h * 0.4); ctx.arc(x + w * 0.5, y + h * 0.4, w * 0.2, Math.PI, 0);
        }
      },
      'key': {
        name: 'Key', icon: 'üîë', path: (ctx, x, y, w, h) => {
          ctx.arc(x + w * 0.2, y + h * 0.5, w * 0.2, 0, 2 * Math.PI);
          ctx.moveTo(x + w * 0.4, y + h * 0.5); ctx.lineTo(x + w * 0.9, y + h * 0.5);
          ctx.lineTo(x + w * 0.9, y + h * 0.7);
          ctx.moveTo(x + w * 0.7, y + h * 0.5); ctx.lineTo(x + w * 0.7, y + h * 0.7);
        }
      },
      'envelope': {
        name: 'Envelope', icon: '‚úâÔ∏è', path: (ctx, x, y, w, h) => {
          ctx.rect(x, y + h * 0.2, w, h * 0.8);
          ctx.moveTo(x, y + h * 0.2); ctx.lineTo(x + w / 2, y + h * 0.6); ctx.lineTo(x + w, y + h * 0.2);
        }
      },
    };

    let wbState = {
      id: null,
      name: "Untitled",
      tool: 'pen',
      shapeType: null, // if tool is shape
      color: '#000000',
      size: 4,
      isDrawing: false,
      startX: 0, startY: 0,
      history: [], // Elements
      redoStack: [],
      canvas: null,
      ctx: null,
      container: null
    };

    // --- Dashboard ---
    function showWhiteboardDashboard() {
      document.getElementById('sidebar').classList.add('hidden');
      // Inline cleanup
      // document.querySelector('.sidebar').style.display = 'none';
      // document.querySelector('.main-chat').style.display = 'none';
      chatArea.classList.add('hidden');
      document.getElementById('welcomeScreen').classList.add('hidden');
      document.getElementById('whiteboardDashboard').classList.remove('hidden');
      loadWhiteboards();
    }

    async function loadWhiteboards() {
      const grid = document.getElementById('wbGrid');
      grid.innerHTML = '<p>Loading...</p>';
      try {
        const boards = await api('/api/whiteboards');
        grid.innerHTML = '';
        if (boards.length === 0) {
          grid.innerHTML = '<p>No whiteboards yet. Create one!</p>';
          return;
        }
        boards.forEach(b => {
          const card = document.createElement('div');
          card.className = 'wb-card';
          card.innerHTML = `
                    <div class="wb-thumbnail">${b.thumbnail ? '<img src="' + b.thumbnail + '" style="width:100%;height:100%;object-fit:cover;">' : 'üé®'}</div>
                    <div class="wb-title">${b.name}</div>
                    <div class="wb-date">${new Date(b.updated_at).toLocaleDateString()}</div>
                    <button onclick="deleteWhiteboard(event, ${b.id})" style="position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:white; border-radius:50%; width:24px; height:24px; display:flex; 
                    align-items:center; justify-content:center; border:none;">‚úï</button>
                `;
          card.onclick = (e) => {
            if (e.target.tagName === 'BUTTON') return;
            openWhiteboardStandalone(b.id);
          };
          grid.appendChild(card);
        });
      } catch (e) {
        grid.innerHTML = '<p style="color:red">Failed to load whiteboards</p>';
      }
    }

    async function createNewWhiteboard() {
      try {
        const res = await api('/api/whiteboards', {
          method: 'POST',
          body: JSON.stringify({ name: "Untitled Whiteboard" })
        });
        openWhiteboardStandalone(res.id);
      } catch (e) {
        alert("Error creating whiteboard: " + e.message);
      }
    }

    async function deleteWhiteboard(e, id) {
      e.stopPropagation();
      if (!confirm("Delete this whiteboard?")) return;
      try {
        await api(`/api/whiteboards/${id}`, { method: 'DELETE' });
        loadWhiteboards();
      } catch (e) {
        alert("Failed to delete");
      }
    }

    // --- UI & Interaction ---
    async function openWhiteboardStandalone(id) {
      try {
        const data = await api(`/api/whiteboards/${id}`);
        wbState.id = data.id;
        wbState.name = data.name;
        wbState.history = data.data ? JSON.parse(data.data) : [];
        wbState.redoStack = [];

        document.getElementById('wbTitle').value = wbState.name;
        document.getElementById('whiteboardUI').classList.remove('hidden');

        initWhiteboardCanvas();
        redrawCanvas();
        renderShapePicker();
      } catch (e) {
        alert("Failed to open whiteboard: " + e.message);
      }
    }

    function initWhiteboardCanvas() {
      wbState.container = document.getElementById('wbCanvasContainer');
      wbState.canvas = document.getElementById('wbCanvasNew');
      wbState.ctx = wbState.canvas.getContext('2d');
      wbState.canvas.width = 3000;
      wbState.canvas.height = 3000;

      const cvs = wbState.canvas;
      cvs.addEventListener('mousedown', wbStart);
      cvs.addEventListener('mousemove', wbMove);
      cvs.addEventListener('mouseup', wbEnd);
      cvs.addEventListener('mouseout', wbEnd);

      cvs.addEventListener('touchstart', (e) => {
        if (wbState.tool === 'pen' || wbState.tool === 'eraser') e.preventDefault();
        wbStart(e.touches[0]);
      });
      cvs.addEventListener('touchmove', (e) => {
        if (wbState.tool === 'pen' || wbState.tool === 'eraser') e.preventDefault();
        wbMove(e.touches[0]);
      });
      cvs.addEventListener('touchend', wbEnd);
    }

    function closeWhiteboardUI() {
      document.getElementById('whiteboardUI').classList.add('hidden');
      loadWhiteboards();
    }

    function wbGetPos(e) {
      const rect = wbState.canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (wbState.canvas.width / rect.width),
        y: (e.clientY - rect.top) * (wbState.canvas.height / rect.height)
      };
    }

    function wbStart(e) {
      if (e.target.id === 'wbTextInput') return; // Don't trigger on input click
      wbState.isDrawing = true;
      const pos = wbGetPos(e);
      wbState.startX = pos.x;
      wbState.startY = pos.y;

      if (wbState.tool === 'select') {
        const hit = wbHitTest(pos.x, pos.y);
        if (hit) {
          wbState.selection = hit;
          wbState.isDragging = true;
          // Bring to front (optional, but good UX)
          // wbState.history.splice(wbState.history.indexOf(hit), 1);
          // wbState.history.push(hit);
        } else {
          wbState.selection = null;
        }
        redrawCanvas(); // To show selection highlight
      } else if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.currentPath = {
          type: 'path',
          points: [{ x: pos.x, y: pos.y }],
          color: wbState.tool === 'eraser' ? '#ffffff' : wbState.color,
          size: wbState.tool === 'eraser' ? wbState.size * 5 : wbState.size,
          isEraser: wbState.tool === 'eraser'
        };
      }
    }

    function wbMove(e) {
      if (!wbState.isDrawing && !wbState.isDragging) return;
      const pos = wbGetPos(e);

      if (wbState.tool === 'select' && wbState.selection && wbState.isDragging) {
        const dx = pos.x - wbState.startX;
        const dy = pos.y - wbState.startY;

        const item = wbState.selection;
        if (item.type === 'path') {
          item.points.forEach(p => { p.x += dx; p.y += dy; });
        } else {
          item.x += dx;
          item.y += dy;
        }

        wbState.startX = pos.x;
        wbState.startY = pos.y;
        redrawCanvas();
        return;
      }

      if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.currentPath.points.push({ x: pos.x, y: pos.y }); // ... existing logic
        // Inline Redraw Optimization
        const ctx = wbState.ctx;
        ctx.beginPath();
        const pts = wbState.currentPath.points;
        if (pts.length > 1) {
          ctx.moveTo(pts[pts.length - 2].x, pts[pts.length - 2].y);
          ctx.lineTo(pos.x, pos.y);

          if (wbState.tool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
          } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = wbState.currentPath.color;
          }

          ctx.lineWidth = wbState.currentPath.size;
          ctx.lineCap = 'round';
          ctx.stroke();
          ctx.globalCompositeOperation = 'source-over';
        }
      }
      // ... (shape logic remains same, but need to bring it here if replacing whole block)
      else if (wbState.tool === 'shape') {
        redrawCanvas();
        const ctx = wbState.ctx;
        ctx.beginPath();
        ctx.strokeStyle = wbState.color;
        ctx.lineWidth = wbState.size;
        const w = pos.x - wbState.startX;
        const h = pos.y - wbState.startY;
        const def = SHAPES[wbState.shapeType];
        if (def) { def.path(ctx, wbState.startX, wbState.startY, w, h); ctx.stroke(); }
      }
    }

    function wbEnd(e) {
      if (wbState.isDragging) {
        wbState.isDragging = false;
        saveWhiteboard(true);
        return;
      }
      if (!wbState.isDrawing) return;
      wbState.isDrawing = false;

      if (wbState.tool === 'pen' || wbState.tool === 'eraser') {
        wbState.history.push(wbState.currentPath);
      } else if (wbState.tool === 'shape') {
        // ... existing shape end logic
        let pos; try { pos = wbGetPos(e); } catch (ex) { return; }
        const w = pos.x - wbState.startX;
        const h = pos.y - wbState.startY;
        if (Math.abs(w) > 5 || Math.abs(h) > 5) {
          wbState.history.push({
            type: 'shape', shape: wbState.shapeType,
            x: wbState.startX, y: wbState.startY, w: w, h: h,
            color: wbState.color, size: wbState.size
          });
        }
        redrawCanvas();
      }
      saveWhiteboard(true);
    }

    // --- Helpers for Text & Select ---
    function wbHitTest(x, y) {
      // Iterate backwards
      for (let i = wbState.history.length - 1; i >= 0; i--) {
        const item = wbState.history[i];
        if (item.type === 'shape') {
          const minX = Math.min(item.x, item.x + item.w);
          const maxX = Math.max(item.x, item.x + item.w);
          const minY = Math.min(item.y, item.y + item.h);
          const maxY = Math.max(item.y, item.y + item.h);
          if (x >= minX && x <= maxX && y >= minY && y <= maxY) return item;
        } else if (item.type === 'path') {
          // Simple bounding box for paths
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          item.points.forEach(p => {
            if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
          });
          // Add padding
          const pad = item.size + 5;
          if (x >= minX - pad && x <= maxX + pad && y >= minY - pad && y <= maxY + pad) return item;
        }
      }
      return null;
    }

    // Text tool removed per user request

    // Global Key Listener for Delete
    window.addEventListener('keydown', (e) => {
      // Only if whiteboard is visible
      if (document.getElementById('whiteboardUI').classList.contains('hidden')) return;

      // If typing in text input, don't delete
      if (document.getElementById('wbTextInput').style.display === 'block') return;
      if (e.target.tagName === 'INPUT') return; // Don't delete when typing in title

      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (wbState.selection) {
          const index = wbState.history.indexOf(wbState.selection);
          if (index > -1) {
            wbState.history.splice(index, 1);
            wbState.selection = null;
            redrawCanvas();
            saveWhiteboard(true);
          }
        }
      }
    });

    function redrawCanvas() {
      const ctx = wbState.ctx;
      ctx.clearRect(0, 0, wbState.canvas.width, wbState.canvas.height);

      wbState.history.forEach(action => {
        ctx.beginPath();
        ctx.globalCompositeOperation = 'source-over';

        // Highlight selection
        if (wbState.selection === action) {
          ctx.shadowColor = 'cyan';
          ctx.shadowBlur = 10;
        } else {
          ctx.shadowBlur = 0;
        }

        if (action.type === 'path') {
          if (action.isEraser) {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
          } else {
            ctx.strokeStyle = action.color;
          }
          ctx.lineWidth = action.size;
          ctx.lineCap = 'round';
          if (action.points.length > 0) {
            ctx.moveTo(action.points[0].x, action.points[0].y);
            for (let i = 1; i < action.points.length; i++) {
              ctx.lineTo(action.points[i].x, action.points[i].y);
            }
          }
          ctx.stroke();
        } else if (action.type === 'shape') {
          ctx.strokeStyle = action.color;
          ctx.lineWidth = action.size;
          const def = SHAPES[action.shape];
          if (def) def.path(ctx, action.x, action.y, action.w, action.h);
          ctx.stroke();
        } else if (action.type === 'text') {
          ctx.fillStyle = action.color;
          ctx.font = `${action.size * 3}px sans-serif`; // Consistent font sizing
          ctx.fillText(action.text, action.x, action.y);
        }
        ctx.shadowBlur = 0; // Reset
      });
      ctx.globalCompositeOperation = 'source-over';
    }

    // --- Toolbar ---
    function setTool(tool) {
      wbState.tool = tool;
      document.querySelectorAll('.wb-tool-btn').forEach(b => b.classList.remove('active'));
      document.getElementById(`tool-${tool === 'shape' ? 'shapes' : tool}`).classList.add('active');

      if (tool !== 'shape') document.getElementById('wbShapePicker').style.display = 'none';
    }

    function setColor(c) { wbState.color = c; }
    function setSize(s) { wbState.size = s; }

    function toggleShapePicker() {
      const p = document.getElementById('wbShapePicker');
      p.style.display = p.style.display === 'grid' ? 'none' : 'grid';
    }

    function setShape(shape) {
      wbState.tool = 'shape';
      wbState.shapeType = shape;
      document.querySelectorAll('.wb-tool-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('tool-shapes').classList.add('active');
      toggleShapePicker();
    }

    function renderShapePicker() {
      const picker = document.getElementById('wbShapePicker');
      picker.innerHTML = '';
      Object.keys(SHAPES).forEach(k => {
        const div = document.createElement('div');
        div.className = 'wb-shape-item';
        div.innerHTML = `<span style="font-size:1.5rem;">${SHAPES[k].icon}</span>`;
        div.title = SHAPES[k].name;
        div.onclick = () => setShape(k);
        picker.appendChild(div);
      });
    }

    // --- Listener Setup ---
    function setupWhiteboardListeners() {
      const canvas = document.getElementById('wbCanvasNew');
      if (!canvas) return;

      // Mouse Events
      canvas.addEventListener('mousedown', wbStart);
      canvas.addEventListener('mousemove', wbMove);
      canvas.addEventListener('mouseup', wbEnd);
      canvas.addEventListener('mouseleave', wbEnd);

      // Touch Events
      canvas.addEventListener('touchstart', wbStart, { passive: false });
      canvas.addEventListener('touchmove', wbMove, { passive: false });
      canvas.addEventListener('touchend', wbEnd);
    }

    // Open Whiteboard in Chat Context
    async function openChatWhiteboard() {
      if (!currentChatId) return;

      // Reset state for new session
      wbState.history = [];
      wbState.redoStack = [];
      wbState.name = currentChatName ? `Whiteboard: ${currentChatName}` : "Chat Whiteboard";

      document.getElementById('wbTitle').value = wbState.name;
      document.getElementById('whiteboardUI').classList.remove('hidden');

      setupWhiteboardListeners();

      // Request latest state from peers
      if (socket) {
        socket.emit('whiteboard_request_state', {
          chat_type: currentChatType,
          chat_id: currentChatId
        });
      }
    }

    // Call this when opening WB (Standalone)
    const originalOpenWB = openWhiteboardStandalone;
    openWhiteboardStandalone = async function (id) {
      await originalOpenWB(id);

      // Ensure state is initialized
      wbState.canvas = document.getElementById('wbCanvasNew');
      wbState.ctx = wbState.canvas.getContext('2d');
      wbState.container = document.getElementById('wbCanvasContainer');

      setupWhiteboardListeners();
    };

    // Auto-init for standalone dev/testing if needed, or just rely on open.
    // Better: init on load if element exists
    setupWhiteboardListeners();


    // --- Socket.IO Sync Logic ---
    function setupWhiteboardSocket() {
      if (!socket) return;

      socket.on('whiteboard_draw', (data) => {
        // Check if it's THIS whiteboard context
        // Ideally check ID, but for now we trust the room
        wbState.history.push(data);
        redrawCanvas();
      });

      socket.on('whiteboard_update', (data) => {
        // Find item by some ID? 
        // We don't have UUIDs for items yet. Index sync is flaky if history differs.
        // PRO FIX: We need UUIDs for items. 
        // Quick Fix: For now, we might just append 'update' events or trust order.
        // Real-time moving requires identifying the object.
        // Let's skip move-sync for this exact second until we add IDs, 
        // OR just sync "Add/Delete" and "Clear".
        // User requested interaction.
        // Let's implement full state sync for simplicity: receive full history? No, too heavy.
        // Let's implement standard draw sync first.
      });

      socket.on('whiteboard_delete', (data) => {
        // Deletion sync needs ID.
        // If we don't have IDs, we can't delete specific remote items easily.
        // Allow Clear.
      });

      socket.on('whiteboard_clear', () => {
        wbState.history = [];
        redrawCanvas();
      });
    }

    // Inject socket listeners when connecting
    const originalConnect = connectSocket;
    connectSocket = function (token) {
      originalConnect(token);
      setupWhiteboardSocket();
    };

    // --- Emit Logic Updates ---
    // Update wbEnd to emit
    const originalWbEnd = wbEnd;
    wbEnd = function (e) {
      // Capture history length before
      const len = wbState.history.length;
      originalWbEnd(e);
      const newLen = wbState.history.length;

      if (newLen > len && socket && currentChatId) {
        // Last item was added
        const item = wbState.history[newLen - 1];
        socket.emit('whiteboard_draw', {
          ...item,
          chat_type: currentChatType,
          chat_id: currentChatId
        });
      }
    };

    /* 
    // Update commitText to emit - REMOVED as commitText is not defined
    const originalCommitText = commitText;
    commitText = function () {
      const len = wbState.history.length;
      originalCommitText();
      const newLen = wbState.history.length;

      if (newLen > len && socket && currentChatId) {
        const item = wbState.history[newLen - 1];
        socket.emit('whiteboard_draw', {
          ...item,
          chat_type: currentChatType,
          chat_id: currentChatId
        });
      }
    };
    */

    // Update global delete listener to emit (skipping complex ID logic for now)
    // We will confirm delete works locally first. Syncing delete requires IDs. 
    // I'll add UUIDs to items in next step if requested.

    // Persistence ---
    async function saveWhiteboardName() {
      wbState.name = document.getElementById('wbTitle').value;
      saveWhiteboard();
    }

    async function saveWhiteboard(silent = false) {
      if (!wbState.id) {
        // In chat mode, we don't save to a persistent ID yet (Live Sync handles it)
        if (!silent) {
          const status = document.getElementById('wbSaveStatus');
          status.textContent = 'Saved (Chat)';
          setTimeout(() => status.textContent = 'Saved', 2000);
        }
        return;
      }
      const status = document.getElementById('wbSaveStatus');
      if (!silent) status.textContent = 'Saving...';

      try {
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = 300; thumbCanvas.height = 200;
        const tCtx = thumbCanvas.getContext('2d');
        tCtx.fillStyle = 'white';
        tCtx.fillRect(0, 0, 300, 200);
        tCtx.drawImage(wbState.canvas, 0, 0, 300, 200);
        const thumb = thumbCanvas.toDataURL('image/jpeg', 0.5);

        await api(`/api/whiteboards/${wbState.id}/save`, {
          method: 'POST',
          body: JSON.stringify({
            name: wbState.name,
            data: JSON.stringify(wbState.history),
            thumbnail: thumb
          })
        });
        status.textContent = 'Saved';
        setTimeout(() => status.textContent = 'Saved', 2000);
      } catch (e) {
        status.textContent = 'Error Saving';
        console.error(e);
      }
    }
    // --- Status Like Logic ---
    async function toggleStatusLike(statusId) {
      try {
        const res = await api(`/api/status/${statusId}/like`, { method: 'POST' });
        // Socket will handle UI update, but we can optimistically update if single user
        // Actually, let's rely on socket or response for consistency
        if (currentStatusGroup && currentViewerItemIdx >= 0) {
          const status = currentStatusGroup.statuses[currentViewerItemIdx];
          if (status.id === statusId) {
            status.likes_count = res.count;
            status.is_liked = res.liked;
            updateLikeUI(res.count, res.liked);
          }
        }
      } catch (e) {
        console.error("Like failed", e);
      }
    }

    function updateLikeUI(count, isLiked) {
      const btn = document.getElementById('statusLikeBtn');
      const countEl = document.getElementById('statusLikeCount');
      if (btn) {
        btn.textContent = isLiked ? '‚ù§Ô∏è' : 'ü§ç';
        btn.className = `status-like-btn ${isLiked ? 'liked' : ''}`;
      }
      if (countEl) {
        countEl.textContent = count > 0 ? count : '';
      }
    }

    // Connect socket listener
    const originalConnect2 = connectSocket;
    connectSocket = function (token) {
      originalConnect2(token);
      socket.on('status_like_update', (data) => {
        // Update data model if exists
        if (statusData_Friends) {
          for (let group of statusData_Friends) {
            for (let s of group.statuses) {
              if (s.id === data.status_id) {
                s.likes_count = data.count;
                if (currentUser.id === data.user_id) s.is_liked = data.liked;
              }
            }
          }
        }
        if (statusData_My) {
          for (let s of statusData_My) {
            if (s.id === data.status_id) {
              s.likes_count = data.count;
              if (currentUser.id === data.user_id) s.is_liked = data.liked;
            }
          }
        }

        // Update UI if viewing
        if (currentStatusGroup && currentViewerItemIdx >= 0) {
          const viewingId = currentStatusGroup.statuses[currentViewerItemIdx].id;
          if (viewingId === data.status_id) {
            // Check if *I* did it to set is_liked correctly (or rely on data.liked if user_id matches me)
            const isMe = (data.user_id === currentUser.id);
            let amILiking = isMe ? data.liked : (currentStatusGroup.statuses[currentViewerItemIdx].is_liked);
            updateLikeUI(data.count, amILiking);
          }
        }
      });
    };

    // --- Share Logic ---
    let shareContext = null; // { type: 'whiteboard'|'notepad', id: int }

    async function openShareModal(type, id) {
      if (!id) return alert("Nothing to share");
      shareContext = { type, id };
      document.getElementById('shareItemModal').classList.remove('hidden');

      const list = document.getElementById('shareFriendList');
      list.innerHTML = 'Loading friends...';

      try {
        const friends = await api('/friends');
        list.innerHTML = '';
        if (friends.length === 0) {
          list.innerHTML = '<p style="padding:10px;text-align:center;">No friends available</p>';
          return;
        }

        friends.forEach(f => {
          const div = document.createElement('div');
          div.className = 'chat-item';
          div.innerHTML = `
                <img src="${avatar(f.profile_image, f.username)}" class="dp">
                <span>${f.username}</span>
            `;
          // Add Send Button
          const btn = document.createElement('button');
          btn.textContent = 'Send Copy';
          btn.style.marginLeft = 'auto';
          btn.style.padding = '5px 10px';
          btn.style.fontSize = '0.8rem';
          btn.onclick = (e) => {
            e.stopPropagation();
            sendShare(f.id);
          };
          div.appendChild(btn);
          list.appendChild(div);
        });
      } catch (e) {
        list.innerHTML = '<p style="color:red">Error loading friends</p>';
      }
    }

    async function sendShare(targetUserId) {
      if (!shareContext) return;
      const { type, id } = shareContext;
      const endpoint = type === 'whiteboard' ? `/api/whiteboards/${id}/share` : `/api/notepads/${id}/share`;

      try {
        await api(endpoint, {
          method: 'POST',
          body: JSON.stringify({ target_user_id: targetUserId })
        });
        alert("Sent successfully!");
        document.getElementById('shareItemModal').classList.add('hidden');
      } catch (e) {
        alert("Share failed: " + e.message);
      }
    }

    // --- PDF Download Logic ---
    function downloadNotepadPDF() {
      const doc = new jspdf.jsPDF();
      const content = document.getElementById('noteContent').value;
      const title = document.getElementById('noteTitle').value || "Note";

      // Add Title
      doc.setFontSize(18);
      doc.text(title, 10, 10);

      // Add Content (Split text to fit page)
      doc.setFontSize(12);
      const lines = doc.splitTextToSize(content, 180);
      doc.text(lines, 10, 20);

      doc.save(`${title}.pdf`);
    }
    // --- DELTA AI Logic ---
    function openDeltaModal() {
      document.getElementById('deltaModal').classList.remove('hidden');
      document.getElementById('deltaResultArea').classList.add('hidden');
      document.getElementById('deltaResultArea').textContent = '';
      document.getElementById('deltaQuery').value = '';
    }

    async function triggerDelta(action) {
      const content = document.getElementById('noteContent').value;
      if (!content.trim()) return alert("Note is empty!");

      const resultArea = document.getElementById('deltaResultArea');
      resultArea.classList.remove('hidden');
      resultArea.innerHTML = 'Thinking... <span style="animation:pulse 1s infinite">‚ú®</span>';

      let query = '';
      if (action === 'qa') {
        query = document.getElementById('deltaQuery').value;
        if (!query.trim()) return alert("Please enter a question.");
      }

      try {
        const res = await api('/api/delta/ask', {
          method: 'POST',
          body: JSON.stringify({ content, action, query })
        });

        // Show result
        resultArea.innerHTML = '';
        // Simple Markdown parsing for bold/lists if needed, or just text
        // Reusing a known trick or just exact text
        resultArea.textContent = res.result;

        // Add "Append" button if successful
        const btnId = 'deltaAppendBtn_' + Date.now();
        resultArea.innerHTML += `<br><button id="${btnId}" style="margin-top:10px; font-size:0.8rem; padding:4px 8px;">Append to Note</button>`;
        setTimeout(() => {
          document.getElementById(btnId).onclick = () => {
            document.getElementById('noteContent').value += "\\n\\n--- DELTA AI ---\\n" + res.result;
            document.getElementById('deltaModal').classList.add('hidden');
            saveNotepad();
          };
        }, 0);

      } catch (e) {
        resultArea.innerHTML = `<span style="color:#ef4444">Error: ${e.message}</span>`;
      }
    }
  </script>
</body>

</html>